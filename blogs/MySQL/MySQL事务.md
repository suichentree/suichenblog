---
title: MySQL事务
date: 2022-07-08
sidebar: 'auto'
categories: 
 - 数据库
tags:
 - MySql
---

[toc]

# MySQL事务

## 事务的介绍

事务可以由一条非常简单的SQL语句组成，也可以由一组复杂的SQL语句组成。事务处理可以用来维护数据库的完整性，保证成批的 SQL语句要么全部执行，要么全部不执行。

事务需遵循ACID四个特性：

* A（atomicity）原子性。原子性指整个事务是不可分割的工作单位。一个事务中的所有操作，要么全部完成，要么全部不完成。事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。
* C（consistency）一致性。指在事务开始之前和事务结束以后，从实际的业务逻辑上来说，最终结果是对的、是跟程序员的所期望的结果完全符合的。
例如：A和B互相转账。一致性就是要保证转账前后，A和B的账号金额总体一样。

* I（isolation）隔离性。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务的隔离性分为不同级别，包括读未提交、读提交、可重复读和串行化。
* D（durability）持久性。指事务一旦提交，其结果就是永久性的，即便系统故障也不会丢失。

## ACID实现原理

### A（atomicity）原子性实现原理

mysql的InnoDB引擎实现回滚靠的是undo.log日志文件，当事务对数据库进行修改时，InnoDB会生成对应的undo.log日志文件。如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo.log日志文件中的信息将数据回滚到修改之前的样子。

undo.log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB引擎会根据undo.log的内容做与之前相反的工作。对于insert，回滚时会执行delete。对于delete，回滚时会执行insert。对于update，回滚时则会执行相反的update，把数据改回去。

### D（durability）持久性实现原理

事务的一致性原理关系到InnoDB引擎的BufferPool机制。

InnoDB引擎的BufferPool机制:
InnoDB存储引擎中数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。因此InnoDB提供了缓存(BufferPool)。BufferPool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool。当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo.log日志文件被引入来解决这个问题。当数据修改时，除了修改BufferPool中的数据，还会在redo.log日志文件记录这次操作。如果MySQL宕机，重启时可以读取redo.log日志文件中的数据，对数据库进行恢复。redo.log采用的是所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

### I（isolation）隔离性实现原理

mysql的InnoDB引擎通过锁机制和MVCC机制来保证事务的隔离性

* 锁机制：控制(一个事务)写操作对(另一个事务)写操作的影响
事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

锁可以分为表锁，行锁，二者中间的锁。表锁在操作数据时会锁定整张表，并发性能较差。行锁则只锁定需要操作的数据，并发性能好。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

* MVVC机制：控制(一个事务)写操作对(另一个事务)读操作的影响

暂无

### C（consistency）一致性实现原理

原子性、持久性和隔离性，都是为了保证数据库状态的一致性。

## 事务的分类

事务的分类：扁平事务（即普通事务）,带有保存点的扁平事务,链事务,嵌套事务,分布式事务。

>扁平事务（即普通事务）
扁平事务是事务类型中最简单最常用的一种事务。其由BEGIN WORK开始，由COMMIT WORK或ROLLBACK WORK结束。扁平事务中的操作是原子的，要么都执行，要么都回滚。

>带有保存点的扁平事务
该事务通过保存点（Savepoint）来通知系统应该记住事务当前的状态，允许在事务执行过程中回滚到同一事务中较早的一个状态。

>链事务
链事务的思想是：在提交一个事务时，将必要的处理上下文隐式地传给下一个要开始的事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。这意味着下一个事务将看到上一个事务的结果，就好像在一个事务中进行的。

![mysql20220718155241.png](../blog_img/mysql20220718155241.png)

<font color="red">

链事务与带有保存点的扁平事务不同的是：
1. 带有保存点的扁平事务能回滚到任意正确的保存点。而链事务中的回滚只限于当前事务，即只能恢复到最近一个的保存点。
2. 链事务在执行COMMIT后即释放了当前事务所持有的锁，而带保存点的扁平事务不影响迄今为止所有的锁。

</font>

>嵌套事务
由一个顶层事务（top-level transaction）控制着各个层次的事务。顶层事务之下嵌套的事务被称为子事务（subtransaction），其控制每一个局部的变换。

![mysql20220718155440.png](../blog_img/mysql20220718155440.png)

>分布式事务
是在分布式环境下运行的扁平事务。对于分布式事务，同样需要满足ACID特性，要么都发生，要么都失效

<font color="red">MySQL的InnoDB存储引擎来说，它支持扁平事务、带有保存点的扁平事务、链事务、分布式事务。对于嵌套事务，MySQL数据库并不是原生的，但是可以通过带有保存点的事务来模拟串行的嵌套事务。</font>

## 事务的隔离性级别

事务的隔离性用于防止多个事务并发执行时由于交叉执行而导致数据的不一致。理论上只要事务进行排队执行，则可以保证事务的隔离性。但是事务排队执行又会对性能影响很大。因此最好的解决方法就是根据情况不同来选择不同的隔离性级别。

### 当事务并发执行时会遇到的问题

1. 脏写
如果一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。

![mysql20220718111415.png](../blog_img/mysql20220718111415.png)

2. 脏读
如果一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。

![mysql20220718111920.png](../blog_img/mysql20220718111920.png)

3. 不可重复读
若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。

![mysql20220718114310.png](../blog_img/mysql20220718114310.png)

4. 幻读
幻读强调的是一个事务A按照某个相同条件多次读取记录时，之后读到了之前没有读到的记录。

如果事务A先根据某些条件查询出一些记录，之后另一个已提交的事务B又向表中插入记录，事务A再次按照该条件查询时，会把事务B插入的记录也读出来。即事务执行期间，多次查询结果的条数不相同。这就是幻读

![mysql20220718114853.png](../blog_img/mysql20220718114853.png)


<font color="red">

不可重复读和幻读的区别：
1. 不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。
2. 幻读的重点在于新增或者删除；同样的条件，第1次和第2次读出来的记录数不一样。

</font>

### 事务的4种隔离性级别

上面4种问题的严重程度：脏写 > 脏读 > 不可重复读 > 幻读

根据上面各自问题的严重程度。在事务中设计了4种隔离级别。针对不同的隔离级别，并发事务可以发生不同严重程度的问题。

4种隔离级别:

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

* 读未提交隔离级别下，可能出现脏读,不可重复读,幻读问题。 
* 读已提交隔离级别下，可能出现不可重复读,幻读问题，不会出现发生脏读问题。 
* 可重复读隔离级别下，可能出现幻读问题，不会出现发生脏读,不可重复读的问题。
* 串行化隔离级别下，各种问题都不会出现。

<font color="red">

1. 由于脏写是最严重的问题，所以4种隔离级别都会禁止脏写问题的出现。
2. Mysql中InnoDB存储引擎默认的支持隔离级别是可重复读

</font>

