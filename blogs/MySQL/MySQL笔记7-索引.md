---
title: MySQL笔记7-索引
date: 2023-07-18
sidebar: 'auto'
categories: 
 - 数据库
tags:
 - MySql
---

[toc]

# MySQL笔记7-索引

## 索引的介绍

索引由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。

索引的建立可以大大提高MySQL的检索速度。索引就类似汉语字典中的目录，可以帮助我们快速查询某个字的位置。

> 为什么要使用索引？

MySQL中，通常有以下两种方式查询数据库的数据。
* 逐行访问：即全表扫描，逐行查询，直到查到数据。但是当表中存在大量数据的时候，效率非常低下，会花费大量时间。
* 索引访问：通过遍历索引来查询表中的数据。使用这种方式的前提是对表建立一个索引，在列上创建了索引之后，查找数据时可以直接根据该列上的索引找到对应记录行的位置，从而快捷地查找到数据。

例如，在学生信息表 tb_students 中，如果基于 student_id 建立了索引，mysql系统就建立了一张索引列到实际记录的映射表。当用户需要查找 student_id 为 12022 的数据的时候，系统先在 student_id 索引上找到该记录，然后通过映射表直接找到数据行，并且返回该行数据。因为扫描索引的速度一般远远大于扫描实际数据行的速度，所以采用索引的方式可以大大提高数据库的工作效率。

> 索引的优缺点
* 优点：索引可以大大减小系统需要扫描的数据量，从而大大加快数据的检索速度。
* 缺点：索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间。
* 缺点：过多的索引会大大提高了查询速度，但同时却会降低表的更新速度（增，删，改）。因为MySQL不仅要更新表中的数据，还要更新对应的索引文件。

> 应该被作为索引的列
* WHERE子句中的常用的列应该创建索引。若常用列有许多重复值则不必创建索引。
* 在排序（order by）语句常用的列上应该创建索引，加快排序查询时间。

> 不应该被作为索引的列
* 避免对经常更新的表使用过多的索引
* 在查询条件中很少使用的列不应该创建索引。
* 若表中某个列包含许多重复值(例如性别)，为它建立索引就没有太大的实际效果。
* 数据量小的表最好不要使用索引。
* 参与计算的列字段不适合建索引

> 索引什么情况下会失效？
* like %aaa% 不会使用索引而like aaa% 可以使用索引。
* 不在索引列上做任何操作，例如计算、函数、类型转换，这将导致索引失效。
* 少用or，用它来连接时会索引失效。
* MySQL在使用不等于（!=或者<>）的时候，索引会失效导致全表扫描。

## mysql索引的分类

mysql中的索引可以根据不同的方面进行分类。
* 按字段个数分类：单列索引、组合索引。
* 按字段特性分类：普通索引、唯一索引、主键索引、全文索引，空间索引。
* 按物理存储分类：聚集索引、非聚集索引。
* 按数据结构分类：B+tree索引、Hash索引、Full-text索引。

### 按字段个数分类

* 单列索引：一个索引只包含一个字段。
* 组合索引：一个索引包含两个或两个以上的字段。

#### 组合索引的最左前缀原则

* 组合索引中字段的先后顺序会与where子句中的字段先后顺序进行匹配，匹配上的where子句就能使用索引。
* 按从左到右的顺序依次进行匹配。直到遇到范围查询（>,<,between,like）就停止匹配。
* 例如组合索引index_name(a,b,c)，只会匹配上a、a,b、a,b,c 三种类型的查询。
* <font color="red">注意若子句中abc三个字段都存在，无论什么顺序。where子句会将其优化为a,b,c查询。</font>
* <font color="red">注意若子句中的条件通过>,<,between,like连接。则不会触发索引</font>

```
>例如：某个索引包含三个字段（姓名，年龄，性别）。即aaa_index(name,age,gender)

select * from table where name = '小明'
select * from table where name = '小明' and age = 12
select * from table where name = '小明' and age = 12 and gender = '男'
select * from table where name = '小明' and gender = '男'

只有上面这三个语句能够使用到索引aaa_index。其余的查询语句无法使用到索引aaa_index。
第四个语句只能使用到name字段索引，不能使用到gender字段索引。

>原因解释：

组合索引index_name(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询。a,c顺序只走a字段索引，不会走c字段索引。
```

### 按字段特性分类：普通索引、唯一索引、主键索引、全文索引，空间索引

* 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
* 唯一索引: 数据列不允许重复，允许为NULL值，一个表可以多个列创建唯一索引。
* 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
* 全文索引: 用于支持数据值的全文查找，允许插入重复值和空值。
* 空间索引: 用于对空间数据类型的字段建立的索引，空间索引只能在存储引擎为MyISAM的表中创建。

### 按存储方式分类：聚集索引、非聚集索引

* 聚集索引：将数据和索引存储在一起。找到索引也就找到了数据行。
* 非聚集索引：将数据和索引分开存储,找到索引只是找到了数据行的地址。

在InnoDB存储引擎中，可以把B+树索引也分为聚集索引和非聚集索引。

* 聚集索引（聚簇索引）：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使表中不创建主键，系统也会创建一个隐式的主键。因为innodb存储引擎是把数据存放在B+树中的，而B+树的键值就是主键。在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，称之为聚集索引。

* 非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的B+树索引，称之为非聚集索引。

* 非聚集索引与聚集索引的区别: 在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，称之为回表。

### 按数据结构分类：B+树索引，Hash索引，Full-text索引

由于索引的数据结构类型和存储引擎有关，每种存储引擎所支持的索引数据结构类型不一定完全相同。

下表是MySQL常见的存储引擎 InnoDB，MyISAM 和 Memory 分别支持的索引类型

存储引擎 | InnoDB(默认) | MyISAM | Memory
------------ | ------------- | ------------- | ------------- 
B+树索引 | yes | yes | yes
Hash索引 | no | no | yes
Full-text索引 | yes | yes | no

> B+树索引

暂无

> Hash索引

暂无

> Full-text索引

暂无

## 创建索引

ALTER TABLE 语句也可以在一个已有的表上创建索引。

### 设置表中字段为普通索引
```sql
# 语法如下
alter table 表名 add index 索引名 (字段名1[，字段名2 …]);

alter table employee add index emp_name (name);
```

### 设置表中字段为主键索引
```sql
# 语法如下
alter table 表名 add primary key (字段名);

alter table employee add primary key(id);
```

### 设置表中字段为唯一索引
```sql
# 语法如下
alter table 表名 add unique 索引名 (字段名);

alter table employee add unique emp_name2(cardnumber);
```

### 设置表中字段为全文索引

```sql
# 语法如下
alter table 表名 add FULLTEXT 索引名 (字段名);

alter table employee add fulltext emp_name2(cardnumber);
```

## 查看索引

在 MySQL 中，可以使用 SHOW INDEX 语句查看表中创建的索引。

```sql
# 语法如下
SHOW INDEX FROM <表名>

# 查看表tb_stu的索引信息
SHOW INDEX FROM tb_stu
```

## 删除和修改索引

在 MySQL 中修改索引可以通过删除原索引，再根据需要创建一个同名的索引，从而实现修改索引的操作。

有两种语法用于删除索引。
```sql
# 语法1如下
DROP INDEX 索引名 ON 表名;
# 语法2如下
alter table 表名 drop index 索引名;

# 删除表中索引emp_name
drop index emp_name on employee;
# 删除表中索引emp_name
alter table employee drop index emp_name;
```

## EXPLAIN语句

explain语句可以查看sql语句中索引的使用情况

```
例如： 给TTL字段创建一个索引aaa。
explain select * from pol_law_d where TTL = '111';
```

![20220708160945.png](../blog_img/20220708160945.png)

概要描述：
id:标识符
select_type:表示查询的类型.(SIMPLE表示简单SELECT)
table:表名
partitions:匹配的分区
type:表示表的连接类型
possible_keys:表示查询时，可能使用的索引
key:表示实际使用的索引
key_len:索引字段的长度
ref:列与索引的比较
rows:扫描出的行数(估算的行数)
filtered:按表条件过滤的行百分比
Extra:执行情况的描述和说明


