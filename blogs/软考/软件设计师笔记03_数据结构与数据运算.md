---
title: 软件设计师笔记03_数据结构与数据运算
date: 2025-03-26
sidebar: 'auto'
tags:
 - 软考
---

[toc]

# 软件设计师笔记03_数据结构与数据运算

## 第三章 数据结构与数据运算

数据的结构可以分为线性结构、非线性结构与数据的运算三个部分。

该章节的架构图如下。

![ruankao_20241016163353.png](../blog_img/ruankao_20241016163353.png)

### 线性结构

线性结构的特点是数据元素之间呈现一种线性关系，即元素 “一个接一个排列”。

#### 线性表

线性表是最简单、最基本的线性结构。

线性表常采用顺序存储和链式存储，主要的基本操作是插入、删除和查找等。

> 线性表的存储结构

线性表常采用顺序存储和链式存储，主要的基本操作是插入、删除和查找等。
- 顺序存储：用一组地址连续的存储单元依次存储线性表中的数据元素，使得逻辑上相邻的元素物理上也相邻
- 链式存储：存储各数据元素的结点的地址并不要求是连续的，数据元素逻辑上相邻，物理上分开

![ruankao_20241016171107.png](../blog_img/ruankao_20241016171107.png)
![ruankao_20241016171230.png](../blog_img/ruankao_20241016171230.png)

#### 栈

栈是一种“后进先出”（LIFO）的线性表。在栈中进行插入和删除操作的一端称为栈顶，另一端称为栈底。

![ruankao_20241016174308.png](../blog_img/ruankao_20241016174308.png)

#### 队列

队列是一种“先进先出”（FIFO）的线性表，即在表的一端插入元素，在另一端删除元素。在队列中允许插入元素的一端称为队尾，允许删除元素的一端称为队头。

![ruankao_20241016174326.png](../blog_img/ruankao_20241016174326.png)

#### 串

串是由字符构成的有限序列，也是一种线性表，一般记为 s=“a1a2...an”（n>0），其中，s 是串的名称，用单引号括起来的字符序列是串值。

> 串的基本概念
- 空串：长度为 0 的串称为空串，空串不包含任何字符。
- 空格串：由一个或多个空格组成的串，空格是空白字符，占一个字符长度。
- 子串：由串中任意长度的连续字符构成的序列称为子串。含有子串的串称为主串。空串是任意串的子串。

### 非线性结构

#### 二维数组

二维数组的特点如下：
1. 数据元素数目固定。
2. 数据元素具有相同的类型。
3. 数据元素的下标关系具有上下界约束且下标有序。

一个m行n列的数组表示如下
![ruankao_20241017152445.png](../blog_img/ruankao_20241017152445.png)

> 数组存储地址的计算

假设每个数组元素占用内存长度为len，起始地址为a，存储地址计算如下：

![ruankao_20250326163255.png](../blog_img/ruankao_20250326163255.png)

#### 三对角矩阵

常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。

![ruankao_20241017152645.png](../blog_img/ruankao_20241017152645.png)

#### 树

树是一种非线性结构，树中的每一个数据元素可以有两个或两个以上的直接后继元素，用来描述层次结构关系。

如图所示。
![ruankao_20241017153058.png](../blog_img/ruankao_20241017153058.png)

> 树的基本概念

1. 双亲、孩子和兄弟。结点的子树的根称为该节点的孩子结点；相应地，该结点称为其子结点的双亲。具有相同双亲的结点互为兄弟。
2. 结点的度。一个结点拥有子树的个数称为该结点的度。例如，如图 3-10 中，A 的度为 3，B 的度为 2，C 的度为 0，D 的度为 1。
3. 叶子结点。叶子结点是指度为 0 的结点。例如，图 3-10 中的 E、F、C、G 都是叶子结点。
4. 内部结点。除根结点外，度不为 0 的结点称为内部结点。例如，图 3-10 中的 B、D 都是内部结点。
5. 结点的层次。例如，图 3-10 中的 A 在第一层，B、C、D 在第二层，E、F、G 在第三层。
6. 树的深度。一棵树的最大层数为该树的深度（或高度）。例如，图 3-10 中的树的深度为 3。
7. 有序/无序树。如果树中各结点的各个子树是从左到右有序排列且不能交换时，则称该树为有序树，否则称为无序树。

#### 二叉树

二叉树与普通树的区别在于，每个节点最多只有两个孩子结点。二叉树中结点的子树分为左子树和右子树。

如图所示
![ruankao_20241017153956.png](../blog_img/ruankao_20241017153956.png)

> 满二叉树与完全二叉树与非完全二叉树

- 满二叉树：如果一个二叉树的层数为 K，结点总数为 2^k - 1 个，则它就是满二叉树，如图a所示。
- 完全二叉树：在一个深度为 h 的完全二叉树中，除第 h 层外（最后一层），其他各层都是满的。第 h 层所有的结点都必须从左到右依次放置，不能留空，如图 b 所示。
- 非完全二叉树：除了上面两个情况之外的二叉树就是非完全二叉树，图 c 为非完全二叉树。

![ruankao_20241017154130.png](../blog_img/ruankao_20241017154130.png)

> 二叉树的重要特性

![ruankao_20241017154221.png](../blog_img/ruankao_20241017154221.png)

> 二叉树的存储结构

二叉树的顺序存储结构：顺序存储，就是用一组连续的存储单元存储二叉树中的节点，按照从上到下，从左到右的顺序依次存储每个节点。

在采用顺序存储时，完全二叉树与一般的二叉树相比节省了空间，这是因为一般二叉树需要添加一些“虚结点”而造成了空间的浪费，如图所示。

![ruankao_20241017154449.png](../blog_img/ruankao_20241017154449.png)

二叉树的链式存储结构：一般用二叉链表来存储二叉树节点，二叉链表中除了该节点本身的数据外，还存储有左孩子结点的指针、右孩子结点的指针。每个二叉链表节点存储一个二叉树节点，头指针则指向根节点

在采用链式存储时，二叉树的链式存储可以分为二叉链表和三叉链表的存储结构，如图所示

![ruankao_20241017154521.png](../blog_img/ruankao_20241017154521.png)

> 二叉树的遍历

二叉树的遍历是按某种策略访问树中的每个结点且仅访问一次的过程。

二叉树的遍历可以分为前序、中序、后序和层次遍历四种形式。这四种遍历方式产生的结果如图所示。

![ruankao_20241017154610.png](../blog_img/ruankao_20241017154610.png)

- 先序（前序）遍历：根左右
- 中序遍历：左根右
- 后序遍历：左右根
- 层次遍历：按层次，从上到下，从左到右

> 最优二叉树（哈夫曼树）

哈夫曼树又称为最优二叉树，是一种带权路径长度最短的二叉树。
- 权：节点代表的值
- 路径：树中一个结点到另一个结点之间的通路
- 结点的路径长度：路径上的分支数目
- 树的路径长度：根节点到达每一个叶子节点之间的路径长度之和
- 结点的带权路径长度：该结点到根结点之间的路径长度乘以该节点的权值


所谓树的带权路径长度，就是树中所有的叶子结点的权值乘上其到根结点的路径长度（若根结点为 0 层，叶子结点到根结点的路径长度为叶子结点的层数）。

树的带权路径长度记为 WPL=(W1×L1+W2×L2+W3×L3+…+Wn×Ln)，N 个权值 Wi（i=1,2,…,n）构成一棵有 N 个叶结点的二叉树，相应的叶结点的路径长度为 Li（i=1,2,…,n）。由此可以证明哈夫曼树的带权路径长度是最小的。

#### 图

图是由集合 V 和 E 构成的二元组，记作 G=(V,E)，其中，V 是图中顶点的非空有限集合，E 是图中边的有限集合，如下图所示。

![ruankao_20241017155253.png](../blog_img/ruankao_20241017155253.png)

> 图的存储结构

![ruankao_20241017160058.png](../blog_img/ruankao_20241017160058.png)

![ruankao_20241017160148.png](../blog_img/ruankao_20241017160148.png)

> 图的遍历

图的遍历可以分为深度优先遍历、广度优先遍历两种方式，深度优先遍历类似于树的前序遍历，而广度优先遍历则相当于树的层次遍历。


### 数据运算

#### 查找

> 顺序查找

将待查的元素从头到尾与表中元素进行比较，如果存在，则返回成功；否则，查找失败。此方法效率不高。顺序查找的平均查找长度为(n+1)/2。

> 二分查找

二分查找的前提是元素有序（一般是升序），基本思路是拿中间元素 A [ m ] 与要查找的元素 x 进行比较，如果相等，则表示找到；如果 A [ m ] 比 x 大，那么要找的元素一定在 A [ m ] 前边（左边）；如果 A [ m ] 比 x 小，那么要找的元素一定在 A [ m ] 后边（右边）。每进行一次查找，数组规模减半。反复将子数组规模减半或使当前子数组为空，直到发现要查找的元素

> 哈希查找

设关键序列为 47、34、13、12、52、38、33、27、3，哈希表长为 11，哈希函数为 Hash(key)=key mod 11，则有
- Hash(47) = 47 mod 11= 3，Hash(34) = 34 mod 11= 1，Hash(13) =13 mod 11= 2，
- Hash(12) = 12 mod 11= 4，Hash(52) = 52 mod 11= 8，Hash(38) = 38 mod 11= 5，
- Hash(33) = 33 mod 11= 0，Hash(27) = 27 mod 11= 6，Hash(3) =3 mod 11= 7。

对于产生的冲突，哈希函数可以采用线性探测法解决冲突，哈希地址和关键字的对应关系如表所示。

![ruankao_20241017160904.png](../blog_img/ruankao_20241017160904.png)


#### 排序

> 直接插入排序

在插入第 i 个记录时，R1,R2,...,Ri-1 均已排好序，这时将第 i 个记录依次与 Ri-1,...,R2,R1进行比较，找到合适的位置插入，插入位置及之后的记录依次向后移动。

例如：43 55 70 30 -> 结果：30 43 55 70

直接插入排序在最好情况下的时间复杂度为 O(n)，在最坏情况下的时间复杂度为 O(n^2)

> 冒泡排序

通过相邻元素（i 与 i-1）之间的比较和交换，将排序码较小的元素逐渐从底层移向顶层。整个过程像水底的气泡逐渐向上冒，由此而得名冒泡排序。冒泡排序的时间复杂度为 O(n^2)。

例如：43 55 70 30

排序过程如图所示。

![ruankao_20241017161631.png](../blog_img/ruankao_20241017161631.png)

> 简单选择排序

每一趟从待排序的数据元素中选出最小的元素，顺序放在待排序数列的最前面，直到全部待排
序的数据元素全部排完。简单选择排序的时间复杂度为 O(n^2)。

例如：43 55 70 30
第一趟，最小值 30 与第一个元素交换：30 55 70 45
第二趟，最小值 45 与第二个元素交换：30 45 70 55
第三趟，最小值 55 与第三个元素交换：30 45 55 70

> 希尔排序

先将整个待排元素序列分成若干个子序列（由相隔某个“增量”的元素组成）后分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的。希尔排序的时间复杂度为 O(n^1.3)

> 快速排序

快速排序是对冒泡排序的一种改进。基本思路是：通过一趟排序将要排序的数据分成独立的两个部分，其中一部分的所有数据都比另外一部分的所有数据要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。快速排序在最好情况下的时间复杂度为 O(nlog2^n)；在最坏情况下，即初始序列按关键字有序或基本有序时，快速排序的时间复杂度为 O(n^2)。

![ruankao_20241017162133.png](../blog_img/ruankao_20241017162133.png)

