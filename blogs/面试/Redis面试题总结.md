---
title: Redis面试题
date: 2023-11-07
sidebar: 'auto'
categories:
 - 面试
tags:
 - Redis
---

[toc]

# Redis面试题总结

## 什么是Redis？为什么要用redis?

Redis 是一个 Key-Value 类型的内存数据库。

> 使用redis缓存的目的：高性能，高并发

一般情况下，某个后端服务要进行查询数据请求的时候，通常是直接访问数据库。例如mysql数据库。而mysql数据库的数据都是存储在磁盘中的。

如果对磁盘进行访问的话，由于磁盘本身的限制，存取数据的速度只能达到毫秒级别，即每秒2000并发请求左右。因此当你的并发请求超过2000的时候，只使用mysql数据库的话，应用的访问速度就会变慢。

这是你可以把redis数据库放到后端服务和mysql数据库中间，让后端服务访问redis数据库，如果能再redis中找到想要的数据，就直接返回结果。如果找不到再访问mysql数据库。而redis数据库由于数据是存储再缓存上的，因此访问速度能达到微妙级别。即每秒并发8万左右。

这样就出现一个新的问题，redis数据库如何存储mysql数据库中的数据。

## Redis的数据类型及其使用场景

String、List、Set、Sorted Set、hashes

- String类型：主要用于字符串的存储。
- HASH 类型：是一种键值对的结构。适合存放对象数据，例如系统的用户数据。
- List 类型：存储有序列表。可以存储一些列表型的数据。例如文章评论列表，会议聊天记录等。
- SET 类型： 无序集合，自动去重。可以存储想要去重的数据。例如用户通讯录数据。
- Sorted SET类型：有序集合，自动去重。可以存储想要排序的集合数据。例如各个药店的每日销售额数据，形成一个排行榜。


## 什么是Redis事务？

事务就是一组按照顺序执行的命令，这组命令要么全部被执行，要么全部都不执行。

> redis中如何使用事务？

redis提供了简单的事务功能，可以把一组按照顺序执行的命令放到multi和exec这两个命令之间。

multi命令代表了事务的开始，exec代表了事务的执行与结束。

> redis事务的问题

如果multi和exec命令之间的事务命令存在语法上的错误，那么redis会发现这种错误，并将事务进行回滚。但是如果事务命令之中存在运行逻辑上的错误，那么redis事务不会回滚。

> redis事务的机制

当用户执行multi命令的时候，redis服务器会把用户后续执行的命令缓存起来，直到用户执行exec命令之后，redis服务器才会依次执行这些缓存起来的命令。

## redis的过期策略

> 为什么会有过期策略

redis中存储的数据都有一个过期时间。当过期时间一到，那么redis就会将该数据从数据库中删除。

由于redis是单线程，删除数据也是会占用线程的处理时间。为了保证redis的高性能，因此必须要有一个过期策略，来决定如何删除过期数据，从而保证redis的高性能。

> redis的过期策略

redis的过期策略采用的是定期删除+惰性删除

>> 定期删除的机制

redis会把每个设置了过期时间的key，都会记录到过期字典中。

1. 每隔10s，redis会从过期字典中随机选择20个key。
2. 删除20个key中过期的key。
3. 如果过期key的比例超过1/4，则重复步骤1.

定时删除的机制存在一个问题，就是当大量的key同一时间都过期了。那么会导致redis不断的从过期字典选择并删除key，从而导致redis的卡顿。

解决办法就是不要给大量的key都设置同一个过期时间，过期时间要设置一个随机范围。

>> 惰性删除的机制

当用户读取这个key的时候，redis会对这个key的过期时间进行检查，如果过期了，就立即删除，不会返回任何数据。

## redis的数据淘汰策略是什么？或者 如何保证 redis 中的数据都是热点数据？

Redis的所有数据都存储在内存中，但是内存是一种有限的资源，所以为了防止Redis无限制的使用内存，在Redis中可以通过配置项 maxmemory 来指定其最大能使用的内存容量。

例如可以通过以下配置来设置Redis最大能使用 1G 内存
```
maxmemory 1G
```

当Redis使用的内存超过配置的 maxmemory 时，便会触发数据淘汰策略。Redis提供了多种数据淘汰的策略，如下：
1. noeviction: 不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行。这是默认的数据淘汰策略。
1. volatile-lru：最近最少使用算法，从设置了过期时间的键中选择最少使用的key清除掉。
2. volatile-lfu: 最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉。
3. volatile-ttl：从设置了过期时间的键中选择过期时间最早的键值对清除。
4. volatile-random：从设置了过期时间的键中，随机选择键进行清除。
5. allkeys-lru：最近最少使用算法，从所有的键中选择最少使用的键值对清除。
6. allkeys-lfu: 最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除
7. allkeys-random：所有的键中，随机选择键进行删除。


> 如何配置数据淘汰策略

在Redis中配置文件中通过配置项 maxmemory_policy 来指定要使用的数据淘汰策略。

例如要使用 volatile-lru 策略可以通过以下配置来指定。
```
maxmemory_policy volatile-lru
```

## 什么是 LRU算法？

> 什么是LRU算法？

LRU是 Least Recently Used 的缩写，即最近最少使用，很多缓存系统都使用此算法作为淘汰策略。

最简单的实现方式就是把所有缓存通过一个链表连接起来，新创建的缓存添加到链表的头部，如果有缓存被访问了，就把缓存移动到链表的头部。由于被访问的缓存会移动到链表的头部，所以没有被访问的缓存会随着时间的推移移动的链表的尾部，淘汰数据时只需要从链表的尾部开始即可。

下图展示了这个过程： 

![redis_20231109182209.png](../blog_img/redis_20231109182209.png)

> 什么是redis的LRU算法

redis并不是严格采用LRU算法来进行数据淘汰策略的。而是redis使用的是一种近似LRU算法，这个算法跟LRU算法部分相似。

redis的近似LRU算法，是给每个key额外添加一个小字段，这个字段用于记录key的最近使用时间。当redis发现内存超过maxmemory的时候，会执行一次近似LRU算法。

随机采样5个key，然后淘汰最旧使用的key，如果淘汰掉key后，内存还是超出了maxmemory。则继续随机淘汰，直到内存低于maxmemory为止。

## 什么是缓存穿透

一般情况下，如果用户查询的数据再redis缓存不存在的时候，后台服务会再mysql数据库中再查询一遍。

而缓存穿透就是通过大量伪造的数据不断对系统发起请求，由于伪造的数据在缓存数据中并不存在，因此这些大量的请求会打到mysql数据库上，从而让mysql数据库无法处理正常的请求。

> 缓存穿透的解决办法

两种方式

1. 缓存空对象。例如：如果一个查询返回的数据为空（不管数据是否存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。把空结果存放到缓存，这样第二次从缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

2. 布隆过滤器。 

布隆过滤器：一个判断某个元素是否存在集合中的算法。

如果redis设置了布隆过滤器，通过布隆过滤器可以判断大量的恶意请求要查询的数据是否存在。如果不存在，直接回结果。从而避免了大量恶意请求直接攻击mysql数据库的情况发生。

布隆过滤器的特点：如果某个元素一定不在集合中，那么通过布隆过滤器的算法则一定可以判断该元素在集合中。如果某个元素在集合中，则通过算法则有很小的可能判断出不在集合中。即布隆过滤器有一个很小的误判率。


## 什么是布隆过滤器



## 什么是缓存雪崩

在一般情况下，redis是用于缓存mysql数据库中的热点数据的。用于处理用户大量的高并发查询请求的，减轻mysql数据库的压力的。

但是当redis宕机了或者redis中的数据大规模过期后，会导致redis暂时失效。从而让高并发请求直接由mysql数据库来处理。

因此redis缓存雪崩的原因有两个：redis宕机或redis中的大量数据过期。

> 解决缓存雪崩的方式

方式1：对于redis宕机，我们可以提前搭建redis主从哨兵模式。即当主redis宕机后，从redis变成主redis来提供服务。

方式2：对于redis中的大量数据过期，我们在插入key的时候，就可以将key的过期时间加上一个随机范围,例如1s-60s。我们可以通过这种方式来防止redis中大量key同时失效。从而导致缓存雪崩。

> 缓存雪崩的事前事中事后的解决方案如下。 

- 事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。 
- 事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。 
- 事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。


## 什么是bigkey,它会造成什么不好的影响？

bigkey是指key对于value所占用的内存空间比较大。例如一个字符型的value可以占用512M的字符串。一个列表类型的value存储了上万的元素等。

> bigkey的危害？

由于redis是单线程的，如果reids经常读取bigkey的话，由于bigkey的value占用空间大。因此redis获取bigkey的时间就比较长，而频繁获取bigkey不光会导致redis阻塞也会导致网络阻塞。

> 解决方法

对bigkey进行拆分。


## 如何保证缓存与数据库的双写一致性？

> 最经典的缓存+数据库读写的模式，就是 Cache Aside 模式。 
- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。 
- 更新的时候，先更新数据库，然后再删除缓存。






## Redis 的持久化机制是什么？各自的优缺点？

Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持
久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

Redis提供两种持久化机制 RDB 和 AOF 机制。 

> RDB（redis database）持久化方式,默认的持久化方式

在某个时间点把redis内存的数据以快照的形式保存到硬盘的二进制文件dump.rdb。当redis重启后，通过把dump.rdb文件重新加载到内存，就能达到恢复数据的目的。

优点：
1. 只有一个文件 dump.rdb，方便持久化。
2. 当redis数据量不大的情况下，RDB持久化的效率比AOF高

缺点：
1. 当redis的数据量大的时候，进行RDB持久化会导致redis产生阻塞的情况。
2. RDB持久化机制由于是间隔一段时间进行持久化。因此当redis发生故障的时候，redis可能有一部分数据没有进行持久化，因此会发生数据丢失。

> AOF（Append-only file）持久化方式

AOF持久化机制是以日志的形式，记录Redis的每次写命令。其默认存储文件为appendonly.aof。当Redis重启时，会把appendonly.aof文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

优点：
1. 数据安全，由于指将redis每次的写命令都记录到aof日志中，因此当redis故障的时候，也能够保证数据不会丢失。

缺点：
1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 当redis的数据量大的时候，aof比 rdb 效率低。

> RDB+AOF 混合的持久化方式

RDB的方式会导致数据丢失，AOF的方式性能较差。因此在高并发的场景下，推荐使用RDB和AOF混合的情况下进行redis的持久化。

## Redis 常见性能问题和解决方案(即redis的优化方案)

1. Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务
2. 如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一次   
3. 为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网
4. 尽量避免在压力很大的主库上增加从库。
5. 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master <- Slave1<- Slave2 <- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。

## Redis 为什么是单线程的？

因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了（毕竟采用多线程会有很多麻烦！）Redis利用队列技术将并发访问变为串行访问


## 如果保证redis高可用和高并发？

可以使用redis主从架构或者哨兵架构来保证redis的高可用和高并发。

例如搭建redis的主从架构。主机负责写命令，从机负责读命令。主从之间进行数据备份。主从模式有个缺点，就是当主机挂掉之后，从机需要手动升级为主机。

或者搭建一个redis的哨兵架构。通过sentinel哨兵来监控主从redis。当主机挂掉之后，哨兵自动将从机升为主机。


## redis 的并发竞争问题是什么？如何解决这个问题？了解redis 事务的 CAS 方案吗？

某个时刻，当多个服务实例都去更新同一个key。可以基于 zookeeper 实现分布式锁。每个服务实例需要通过zookeeper 获取分布式锁，确保同一时间，只能有一个系统实例在操作某个 key，别人都不允许读和写。

当某个服务实例更新完key后，其他服务实例会根据这个key的情况，来判断自己是否还要继续更新这个key。否则就放弃更新这个key。



