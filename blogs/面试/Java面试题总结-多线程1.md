---
title: Java面试题总结-多线程1
date: 2023-08-11
sidebar: 'auto'
categories: 
 - 面试
tags:
 - Java
---

[toc]

# Java面试题总结-多线程1

## 线程的状态与方法

![20201022160451.png](../blog_img/20201022160451.png)

> 线程状态如下：

1. 初始状态（New）：新创建了一个线程对象。
2. 就绪状态（Runnable）：当其他线程调用了线程对象的start()方法后。该线程就会进入到可运行线程池中，等待获取CPU的使用权。
3. 运行状态（Running）：就绪状态的线程对象获取了CPU后，开始执行对应的程序代码。
4. 阻塞状态（Blocked）：阻塞状态是线程对象由于某种原因放弃CPU使用权，暂时停止运行。
阻塞的情况分三种：
   - 等待阻塞：运行的线程对象执行wait()方法，JVM会把该线程对象放入等待池中。(wait会释放持有的锁)
   - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
   - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。（注意,sleep是不会释放持有的锁）
1. 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。

> 有关线程的方法如下

```
sleep() wait() yield() notify() notifyAll() join()

sleep()方法：线程执行此方法后会进入到阻塞状态。并且sleep()方法不会释放对象锁。当睡眠时间结束后，便重新开始执行该线程。

wait()方法：wait是Object类的方法，对该对象调用wait方法会导致拥有该对象的锁的线程会放弃该对象的锁资源，进入到等待状态。只有向该对象调用notify方法（或notifyAll方法）后，哪些线程才能进入到就绪状态。

yield()方法是停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话，那么yield()方法将不会起作用，并且由可执行状态后马上又被执行。

join()方法是用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。

notify()方法：object类的方法。只唤醒一个等待状态的线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程。

notifyAll()方法：object类的方法。会唤醒所有等待状态的线程。
```

## notify()和notifyAll()有什么区别？

notify()和notifyAll()都是object类的方法。

notify可以唤醒一个处于wait状态的线程,使其重新争夺对象锁。

notifyall,可以唤醒所有处于wait状态的线程，使其重新争夺对象锁。

## sleep()和wait()有什么区别？

sleep()方法是Thread类的静态方法。

当前线程执行sleep()方法后，会让线程在指定时间暂停执行（休息）。该线程会让出CPU时间片，从而让其他线程争取CPU时间片。当指定的时间到了线程会进入到就绪状态，开始重新争夺CPU时间片。另外，在调用sleep()方法的过程中，线程不会释放对象锁。因此，就是sleep()方法让线程暂停执行，但是其他线程还是无法执行该线程占用的方法。

打个比方，一个人在工厂工作，他感觉已经有些累了。那么他就会跟操作系统说：在未来的半个小时之内我暂时不工作了。这样，操作系统在随后的半个小时里面不会让他工作。这个人虽然不工作了，但是他还是坐在工位上，其他空闲的人，无法干他的工作。当他休息好后，就可以接着继续做未完成的工作。

wait()方法是Object类的方法，调用对象的wait()方法后，当前线程主动放弃CPU时间片，进入等待状态，并释放掉当前线程获得的所有锁。该线程进入等待状态后，只有其他线程调用同一对象的notify()方法或notifyAll()方法时才能唤醒等待池中的该线程进入等锁池，如果线程重新获得锁，该线程就可以进入就绪状态，等待获取CPU时间片，从而重新执行。

> sleep()方法和 wait()方法的区别?

- sleep()方法不会让线程释放对象锁。
- wait()方法会让线程放弃对象锁。

## 为什么wait和notify方法要在同步块中调用？

wait()方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。而如果线程要获取对象的锁，则表示该线程正在执行对象中的同步方法或同步代码块。

所以，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。

在调用对象的notify()和notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。

## yield()方法有什么作用？

yield()方法是Thread类的静态方法。

yield()方法是停止当前线程（即当前线程让出CPU时间片）。让同等优先权的线程或更高优先级的线程有执行的机会。

如果没有同级或更高级的线程，那么执行yield()方法的线程有可能在进入到暂停状态后马上又被执行

## 线程的 sleep()方法和 yield()方法有什么区别？

1. sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
2. 线程执行 sleep()方法后转入阻塞状态，而执行 yield()方法后转入就绪状态；

## 请说出你所知道的线程同步的方法？

wait():使一个线程处于等待状态，并且释放所持有的对象的lock。
sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法。
notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且不是按优先级。
Allnotity():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。

## 使用多线程的好处？使用多线程需要注意的地方？

好处：将一个大任务拆分为几个小任务。然后让多线程分别运行这几个小任务，会比一个单线程运行一个大任务，要快的多。

注意的地方：若多个线程同时对一个全局变量进行访问。这会造成该全局变量的值被同时修改，容易造成错误。

## 什么是线程安全

线程安全就是说多线程并发访问同一代码，不会产生不确定的结果。

例如多个线程可能会同时运行这段一段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。

## 线程池的作用?

线程池就是事先创建若干个可执行的线程放入一个池（容器）中，需要的时候从池中获取线程，从而不用自行创建线程，使用完毕不需要销毁线程而是放回池中，从而减少创建和销毁线程对象的开销。

> 线程池的好处

1. 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 第二：提高响应速度。任务可以不需要等到线程创建就能立即执行。
3. 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，会消耗系统资源，使用线程池可以对线程进行统一的分配。

## Collections.synchronizedMap() 和 ConcurrentHashMap类 有什么区别？

Collections.synchronizedMap()会给Map对象的方法添加synchronized修饰，当线程调用map对象中的方法时，会获取map对象的对象锁。此时其他线程无法调用该map对象的同步方法。

而如果一个线程在访问ConcurrentHashMap对象的某个桶时，其他线程仍然可以对ConcurrentHashMap对象执行某些操作。

在性能方面，ConcurrentHashMap类 优于 Collections.synchronizedMap()。

## synchronized 关键字的作用

synchronized 修饰符可以修饰方法，代码块。
- 修饰普通方法：线程执行同步方法前要获得当前实例对象的锁。相当于给实例对象加锁。
- 修饰静态方法：因为静态成员不属于任何一个实例对象，是属于类的。相当于是给当前类加锁，会作用于类的所有对象实例。例如一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁。
- 修改代码块：线程执行同步代码块前要先获得对象锁。相当于给实例对象加锁。

总结： synchronized 关键字加到 static 静态方法和 synchronized 代码块上是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。

## 简述 synchronized 和 java.util.concurrent.locks.Lock的异同？

Lock 能完成 synchronized 所实现的所有功能；Lock 有比synchronized 更精确的线程语义和更好的性能，而且不强制性的要求一定要获得锁。synchronized 会自动释放锁，而 Lock 一定要求程序员手工释放，并且最好在 finally 块中释放（这是释放外部资源的最好的地方）。

## 什么是线程局部变量？
线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。

## 死锁与活锁的区别？

死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。

产生死锁的必要条件：1、互斥条件：所谓互斥就是进程在某一时间内独占资源。2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。

活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。

## java 中有几种方法可以实现一个线程？

3个方式实现多线程。
* 继承 Thread 类
* 实现 Runnable 接口
* 实现 Callable 接口，需要实现的是 call() 方法

## 当一个线程进入某个对象的一个 synchronized 的实例方法后，其它线程是否可进入此对象的其它方法？

如果其他方法没有 synchronized 的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。

## 乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。

传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。

## SynchronizedMap 和 ConcurrentHashMap 有什么区别？

SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为 map。

ConcurrentHashMap 使用分段锁来保证在多线程下的性能。ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将hash 表分为 16 个桶，诸如 get,put,remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。

## 当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法? 

能，一个实例对象中的synchronized方法只能由一个线程访问。但其他线程可以同时访问这个对象的非synchronized方法 

