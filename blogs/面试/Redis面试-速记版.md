---
title: Redis面试-速记版
date: 2023-11-07
sidebar: 'auto'
categories: 
 - 面试
tags:
 - MySql
---

[toc]

# Redis面试-速记版

## Redis有哪些适合的场景？

1. 会话缓存（Session Cache）
最常用的一种使用 Redis 的情景是会话缓存（session cache）。

2. 全页缓存（FPC）
除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降。

3. 队列
Reids 在内存存储中提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于程序语言对list的push/pop 操作。

4. 排行榜/计数器
Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。

5. 发布/订阅
Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！

## Redis为什么这么快？

纯内存操作。单线程操作，避免了频繁的上下文切换。

## 为什么要用redis?

> 从提高服务性能的角度上

一般情况下，某个后端服务要进行查询数据请求的时候，通常是直接访问数据库。例如mysql数据库。而mysql数据库的数据都是存储在磁盘中的。

如果对磁盘进行访问的话，由于磁盘本身的限制，访问速度只能达到毫秒级别，即每秒2000并发请求左右。因此当你的并发请求超过2000的时候，只使用mysql数据库的话，应用的访问速度就会变慢。

这是你可以把redis数据库放到后端服务和mysql数据库中间，让后端服务访问redis数据库，如果能再redis中找到想要的数据，就直接返回结果。如果找不到再访问mysql数据库。而redis数据库由于数据是存储再缓存上的，因此访问速度能达到微妙级别。即每秒并发8万左右。

这样就出现一个新的问题，redis数据库如何存储mysql数据库中的数据。

## 为什么 Redis 需要把所有数据放到内存中？

磁盘的速度没有内存快。

Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。

## 什么是Redis事务？

事务就是一组按照顺序执行的命令，这组命令要么全部被执行，要么全部都不执行。

> redis中如何使用事务？

redis提供了简单的事务功能，可以把一组按照顺序执行的命令放到multi和exec这两个命令之间。

multi命令代表了事务的开始，exec代表了事务的执行与结束。

> redis事务的问题

如果multi和exec命令之间的事务命令存在语法上的错误，那么redis会发现这种错误，并将事务进行回滚。但是如果事务命令之中存在运行逻辑上的错误，那么redis事务不会回滚。

> redis事务的机制

当用户执行multi命令的时候，redis服务器会把用户后续执行的命令缓存起来，直到用户执行exec命令之后，redis服务器才会依次执行这些缓存起来的命令。

## redis的过期策略

> 为什么会有过期策略

redis中存储的数据都有一个过期时间。当过期时间一到，那么redis就会将该数据从数据库中删除。

由于redis是单线程，删除数据也是会占用线程的处理时间。为了保证redis的高性能，因此必须要有一个过期策略，来决定如何删除过期数据，从而保证redis的高性能。

> redis的过期策略

redis的过期策略采用的是定期删除+惰性删除

>> 定期删除的机制

redis会把每个设置了过期时间的key，都会记录到过期字典中。

1. 每隔10s，redis会从过期字典中随机选择20个key。
2. 删除20个key中过期的key。
3. 如果过期key的比例超过1/4，则重复步骤1.

定时删除的机制存在一个问题，就是当大量的key同一时间都过期了。那么会导致redis不断的从过期字典选择并删除key，从而导致redis的卡顿。

解决办法就是不要给大量的key都设置同一个过期时间，过期时间要设置一个随机范围。

>> 惰性删除的机制

当用户读取这个key的时候，redis会对这个key的过期时间进行检查，如果过期了，就立即删除，不会返回任何数据。

## redis的数据淘汰策略是什么？

Redis的所有数据都存储在内存中，但是内存是一种有限的资源，所以为了防止Redis无限制的使用内存，在Redis中可以通过配置项 maxmemory 来指定其最大能使用的内存容量。

例如可以通过以下配置来设置Redis最大能使用 1G 内存
```
maxmemory 1G
```

当Redis使用的内存超过配置的 maxmemory 时，便会触发数据淘汰策略。Redis提供了多种数据淘汰的策略，如下：
1. noeviction: 不做任何的清理工作，在redis的内存超过限制之后，所有的写入操作都会返回错误；但是读操作都能正常的进行。这是默认的数据淘汰策略。
1. volatile-lru：最近最少使用算法，从设置了过期时间的键中选择最少使用的key清除掉。
2. volatile-lfu: 最近最不经常使用算法，从设置了过期时间的键中选择某段时间之内使用频次最小的键值对清除掉。
3. volatile-ttl：从设置了过期时间的键中选择过期时间最早的键值对清除。
4. volatile-random：从设置了过期时间的键中，随机选择键进行清除。
5. allkeys-lru：最近最少使用算法，从所有的键中选择最少使用的键值对清除。
6. allkeys-lfu: 最近最不经常使用算法，从所有的键中选择某段时间之内使用频次最少的键值对清除
7. allkeys-random：所有的键中，随机选择键进行删除。


> 如何配置数据淘汰策略

在Redis中配置文件中通过配置项 maxmemory_policy 来指定要使用的数据淘汰策略。

例如要使用 volatile-lru 策略可以通过以下配置来指定。
```
maxmemory_policy volatile-lru
```

## 介绍一下redis的LRU算法？

> 什么是LRU算法？

LRU是 Least Recently Used 的缩写，即最近最少使用，很多缓存系统都使用此算法作为淘汰策略。

最简单的实现方式就是把所有缓存通过一个链表连接起来，新创建的缓存添加到链表的头部，如果有缓存被访问了，就把缓存移动到链表的头部。由于被访问的缓存会移动到链表的头部，所以没有被访问的缓存会随着时间的推移移动的链表的尾部，淘汰数据时只需要从链表的尾部开始即可。

下图展示了这个过程： 

![redis_20231109182209.png](../blog_img/redis_20231109182209.png)

> 什么是redis的LRU算法

redis并不是严格采用LRU算法来进行数据淘汰策略的。而是redis使用的是一种近似LRU算法，这个算法跟LRU算法部分相似。

redis的近似LRU算法，是给每个key额外添加一个小字段，这个字段用于记录key的最近使用时间。当redis发现内存超过maxmemory的时候，会执行一次近似LRU算法。

随机采样5个key，然后淘汰最旧使用的key，如果淘汰掉key后，内存还是超出了maxmemory。则继续随机淘汰，直到内存低于maxmemory为止。

## 什么是缓存穿透

一般情况下，如果用户查询的数据再redis缓存不存在的时候，后台服务会再mysql数据库中再查询一遍。

而缓存穿透就是通过大量伪造的数据不断对系统发起请求，由于伪造的数据再缓存数据中并不存在，因此这些大量的请求会打到mysql数据库上，从而让mysql数据库无法处理
正常的请求。

> 缓存穿透的解决办法

两种方式

1. 缓存空对象。例如：如果一个查询返回的数据为空（不管数据是否存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。把空结果存放到缓存，这样第二次从缓存中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。

2. 布隆过滤器。

布隆过滤器：一个判断某个元素是否存在集合中的算法。

如果redis设置了布隆过滤器，通过布隆过滤器可以判断大量的恶意请求要查询的数据是否存在。如果不存在，直接回结果。从而避免了大量恶意请求直接攻击mysql数据库的情况发生。

布隆过滤器的特点：如果某个元素一定不在集合中，那么通过布隆过滤器的算法则一定可以判断该元素在集合中。如果某个元素在集合中，则通过算法则有很小的可能判断出不在集合中。即布隆过滤器有一个很小的误判率。


## 什么是布隆过滤器


## 什么是缓存雪崩

在一般情况下，redis是用于缓存mysql数据库中的热点数据的。用于处理用户大量的高并发查询请求的，减轻mysql数据库的压力的。

但是当redis宕机了或者redis中的数据大规模过期后，会导致redis暂时失效。从而让高并发请求直接由mysql数据库来处理。

因此redis缓存雪崩的原因有两个：redis宕机或redis中的大量数据过期。

> 解决缓存雪崩的方式

方式1：对于redis宕机，我们可以提前搭建redis主从哨兵模式。即当主redis宕机后，从redis变成主redis来提供服务。

方式2：对于redis中的大量数据过期，我们在插入key的时候，就可以将key的过期时间加上一个随机范围,例如1s-60s。我们可以通过这种方式来防止redis中大量key同时失效。从而导致缓存雪崩。


## 什么是bigkey,它会造成什么不好的影响？

bigkey是指key对于value所占用的内存空间比较大。例如一个字符型的value可以占用512M的字符串。一个列表类型的value存储了上万的元素等。

> bigkey的危害？

由于redis是单线程的，如果reids经常读取bigkey的话，由于bigkey的value占用空间大。因此redis获取bigkey的时间就比较长，而频繁获取bigkey不光会导致redis阻塞也会导致网络阻塞。

> 解决方法

对bigkey进行拆分。


## redis如何解决key的冲突？

一般情况下，如果多个业务使用同一个redis服务器，容器导致key的冲突。

解决方法：可以根据业务的不同来命令key，也可以根据业务的不同，来使用不同的数据库。


## Redis 的持久化机制是什么？各自的优缺点？

Redis是一个支持持久化的内存数据库，通过持久化机制把内存中的数据同步到硬盘文件来保证数据持
久化。当Redis重启后通过把硬盘文件重新加载到内存，就能达到恢复数据的目的。

Redis提供两种持久化机制 RDB 和 AOF 机制。 

> RDB（redis database）持久化方式,默认的持久化方式

在某个时间点把redis内存的数据以快照的形式保存到硬盘的二进制文件dump.rdb。当redis重启后，通过把dump.rdb文件重新加载到内存，就能达到恢复数据的目的。

优点：
1. 只有一个文件 dump.rdb，方便持久化。
2. 当redis数据量不大的情况下，RDB持久化的效率比AOF高

缺点：
1. 当redis的数据量大的时候，进行RDB持久化会导致redis产生阻塞的情况。
2. RDB持久化机制由于是间隔一段时间进行持久化。因此当redis发生故障的时候，redis可能有一部分数据没有进行持久化，因此会发生数据丢失。

> AOF（Append-only file）持久化方式

AOF持久化机制是以日志的形式，记录Redis的每次写命令。其默认存储文件为appendonly.aof。当Redis重启时，会把appendonly.aof文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

优点：
1. 数据安全，由于指将redis每次的写命令都记录到aof日志中，因此当redis故障的时候，也能够保证数据不会丢失。

缺点：
1. AOF 文件比 RDB 文件大，且恢复速度慢。
2. 当redis的数据量大的时候，aof比 rdb 效率低。


> RDB+AOF 混合的持久化方式

RDB的方式会导致数据丢失，AOF的方式性能较差。因此在高并发的场景下，推荐使用RDB和AOF混合的情况下进行redis的持久化。


## 热点数据和冷数据是什么？

- 热点数据：修改频率不高，经常访问读取的数据。例如地图数据，商品介绍数据。
- 冷数据，读写次数很少的数据。

