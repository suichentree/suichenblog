---
title: Java面试题总结-基础1
date: 2023-08-11
sidebar: 'auto'
categories: 
 - 面试
tags:
 - Java
---

[toc]

# Java面试题总结-基础1

## mian方法是做什么的？

main 方法是 Java 程序的入口方法，JVM 在运行某一个程序的时候会首先查找该程序的 main 方法。

## hashCode()与equals()
 
若两个对象相等，则hashcode一定也是相同的。

若两个对象有相同的hashcode值，它们也不一定是相等的。

## == 和 equals 的区别是什么

- 对于基本数据类型的变量， == 比较的是实际值。
- 对于引用类型的变量，==比较的是引用的地址。

<font color="red">一般情况下，equal都是比较地址。若类中重写了equal()的。equal()比较的是内容实际值。string类是重写了equal()方法，所以比较的是具体值。</font>

## 值传递和引用传递的区别

值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。 

引用传递：指的是在方法调用时，传递的参数是引用的地址，也就是变量所对应的内存空间的地址。也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。

## 为什么 Java 中只有值传递

Java总是采用按值传递。即方法形参是实参的拷贝。

例如：当一个实例对象作为一个参数被传递到方法中时，参数的值就是该实例对象的引用地址的拷贝。

在方法内，形参指向的对象属性值可以被改变。但是形参引用地址的改变是不会影响到实参的。因为方法结束后，形参就生命就结束了。


## +=有隐含的强制类型转换

short s1 = 1; s1 = s1 + 1; 会报错
* 由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给short 型。

short s1 = 1; s1 += 1; 不会报错
* short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含的强制类型转换

## String、StringBuffer、StringBuilder 有什么区别？

String
- 底层使用的是 private final char[] value 保存字符串。因此String对象是不可变的。
- 因为对象不可变，线程安全

StringBuffer
- 底层用char[] value 保存字符串。因此StringBuffer对象是可变的。
- 内部方法都通过synchronized关键字修饰。线程安全

StringBuilder
- 底层用char[] value 保存字符串。因此StringBuilder对象是可变的。
- 非线程安全。

速度比较： StirngBuilder > StringBuffer > String


## final finally finalize区别

final可以修饰类、变量、方法。
* final 类：表示该类不能被继承。
* final 方法：表示该方法不能被重写。
* final 变量：表示该变量是一个常量。若是基本类型变量，则无法被再次赋值。若是引用变量，则引用地址不可变，但值可变。

finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法写到finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

## 解释内存中的栈(stack)、堆(heap)和方法区(method area)?

1. 通常基本数据类型的变量，对象的引用保存在栈空间；
2. 通过 new 关键字和构造器创建的对象则放在堆空间
3. 方法区存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；

## is-a , has-a ,like-a ，uses-a 分别指什么意思？

is-a，是一个，代表继承关系。 如果A is-a B，那么B就是A的父类。
like-a，像一个，代表接口关系。 如果A like a B，那么B就是A的接口。
has-a，有一个，代表组合关系。 如果A has a B，那么B就是A的组成部分。
uses-a, 用一个，A uses a B 代表A类方法中的参数包含了B类。


## 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收?

对于GC(垃圾收集器)来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，当GC确定一些对象为"不可用"时，GC就有责任回收这些内存空间。
程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

