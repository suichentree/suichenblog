---
title: MySql面试考点总结
date: 2022-10-31
sidebar: 'auto'
categories: 
 - 面试
tags:
 - MySql
---

[toc]

# MySql面试考点总结

## mysql有那些数据类型

整数类型
```
tinyInt         很小的整数(8位二进制)
smallint        小的整数(16位二进制)
mediumint       中等大小的整数(24位二进制)
int(integer)    普通大小的整数(32位二进制)
```

小数类型
```
float           单精度浮点数
double          双精度浮点数
decimal(m,d)    压缩严格的定点数
```

日期类型
```
year            YYYY
time            HH:MM:SS
date            YYYY-MM-DD
datetime        YYYY-MM-DD HH:MM:SS
timestamp       YYYY-MM-DD HH:MM:SS
```

文本、二进制类型
```
CHAR(M)         M为0~65535之间的整数
VARCHAR(M)      M为0~65535之间的整数
BLOB            允许长度0~65535字节
TEXT            允许长度0~65535字节
BINARY(M)       允许长度0~M个字节的定长字节字符串
```

## 存储引擎

常用的存储引擎有以下：
* Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
* MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。

### 说说innodb和myisam的区别？

* 事务：InnoDB支持事务；MyISAM不支持。
* 锁：InnoDB支持行级锁；MyISAM只支持表级锁。
* 索引：InnoDB和MyISAM都用B+树的方式存储索引。
* 全文索引：InnoDB不支持（可通过插件等方式支持）；MyISAM默认支持。 
* 外键：InnoDB支持外键；MyISAM不支持。
* 读写性能：InnoDB增删改性能更优；MyISAM查询性能更优。
* 存储结构：InnoDB在磁盘存储为一个文件；MyISAM在磁盘上存储成三个文件（表定义、数据、索引）。

## 索引
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引可以快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### 索引分类

mysql中的索引可以根据不同的方面进行分类。
* 按字段个数分类：单列索引、组合索引。
* 按字段特性分类：普通索引、唯一索引、主键索引、全文索引，空间索引。
* 按存储方式分类：聚集索引、非聚集索引。
* 按数据结构分类：B+tree索引、Hash索引、Full-text索引。

#### 按字段个数分类：单列索引，组合索引

* 单列索引：一个索引只包含一个字段。
* 组合索引：一个索引包含两个或两个以上的字段。

#### 按字段特性分类：普通索引、唯一索引、主键索引、全文索引，空间索引

* 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。
* 唯一索引: 数据列不允许重复，允许为NULL值，一个表可以多个列创建唯一索引。
* 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。
* 全文索引: 用于支持数据值的全文查找，允许插入重复值和空值。
* 空间索引: 用于对空间数据类型的字段建立的索引，空间索引只能在存储引擎为MyISAM的表中创建。

#### 按存储方式分类：聚集索引、非聚集索引

* 聚集索引：将数据和索引存储在一起。找到索引也就找到了数据行。
* 非聚集索引：将数据和索引分开存储,找到索引只是找到了数据行的地址。

InnoDB存储引擎和MyISAM存储引擎都是以B+树来存储索引的。

在InnoDB存储引擎中，每个表中的数据都会有一个主键，即使表中不创建主键，系统也会创建一个隐式的主键。innodb存储引擎是把数据存放在B+树中的，而B+树的键值就是主键。在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树，称之为聚集索引。

在MyISAM存储引擎中，所有索引都是非聚簇索引。因为B+树的叶子节点存储着数据行的地址。其余节点存储数据行的键值。

#### 按数据结构分类：B+tree索引、Hash索引、Full-text索引

下表是MySQL常见的存储引擎 InnoDB，MyISAM 和 Memory 分别支持的索引类型

存储引擎 | InnoDB(默认) | MyISAM | Memory
------------ | ------------- | ------------- | ------------- 
B+树索引 | yes | yes | yes
Hash索引 | no | no | yes
Full-text索引 | yes | yes | no

### 组合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:
MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。

因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

### 什么是最左前缀原则？什么是最左匹配原则?

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a=1andb=2andc>3andd=4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。=和in可以乱序，比如a=1 and b=2 and c=3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 为什么innodb存储引擎用B+树作为索引？

索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。 

PS:索引最形象的比喻就是图书的目录了。注意数据量大,索引才显得有意义，如果我想要在`[1,2,3,4]`中找到4这个数据，直接全数据检索也很快。

介绍B+树索引，就不得不提二叉排序树，平衡二叉树和B树这三种数据结构。B+树就是从它们演化来的。

#### 二叉排序树

![20221107175851.png](../blog_img/20221107175851.png)

二叉排序树中存储了键(key)和数据(data)。

二叉排序树是具有下列性质的二叉树：
* 若左子树不空，则左子树上所有结点的值均小于它的根结点的值。
* 若右子树不空，则右子树上所有结点的值均大于它的根结点的值。
* 左、右子树也分别为二叉排序树。

二叉排序树的优点：查找的最大次数 就是 二叉排序树的高度。
二叉排序树的缺点：当左/右子树太长，会导致查找性能大打折扣，几乎变成了线性查找。

若二叉排序树出现这样的构造：
![20221108144628.png](../blog_img/20221108144628.png)

对于上面的二叉排序树，若查找id=17的用户信息，需要查找7次，也就相当于全表扫描了。导致这个现象的原因其实是二叉排序树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。

因此为了需要二叉排序树一直保持平衡。出现了平衡二叉树。

#### 平衡二叉树 

平衡二叉树又称AVL树，在二叉排序树的基础上，要求每个节点的左右子树的高度差不能超过1。

下面是平衡二叉树和非平衡二叉树的对比：
![20221108145157.png](../blog_img/20221108145157.png)

平衡二叉树保证了树的构造是平衡的，当插入或删除数据导致不满足平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。

平衡二叉树相比于二叉树来说，查找效率更稳定，总体的查找速度也更快。

#### B树

为了数据的安全性。通常数据库的数据和索引都是存储在磁盘上的。需要注意的是，电脑从磁盘中读取数据时，是按照磁盘块来读取的，并不是一条一条的读。因此理论上把尽量多的数据放进一个磁盘块中，那一次磁盘读取操作就会读取更多数据，那查找数据的时间也会大幅度降低。

若用平衡二叉树作为索引的数据结构，那么每查找一次数据就需要从磁盘中读取一个节点，也就是一个磁盘块。由于平衡二叉树每个节点只存储一个键值对，对于海量数据，会导致平衡二叉树的节点会非常多，高度会非常高。查找数据时也会进行很多次磁盘IO读取，查找数据的效率将会极低。

![20221108150712.png](../blog_img/20221108150712.png)

因此为了解决平衡二叉树每个节点只存储一个键值对的问题，出现了B树。

B树（Balance Tree）即为平衡树的意思，下图即是一颗B树。

![20221108151819.png](../blog_img/20221108151819.png)

图中的每个节点称为页，页就是上面说的磁盘块。从图中看B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点。子节点的个数一般称为阶，上图中的B树每个节点中最多只能有3个子节点，因此称为3阶B树，高度也会很低。

基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。

B树查询流程：例如查询id为28的用户信息。
1. 先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。
2. 将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。
3. 将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。

#### B+树

B+树是对B树的进一步优化。下图是B+树的结构图：

![20221108153650.png](../blog_img/20221108153650.png)

B+树和B树的区别：
1. B树的每个节点都存储键值对数据。而B+树的非叶子节点只存储键值，叶子节点存储键值对数据。之所以这么做是因为在数据库中页的大小是固定的。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。

PS: B+树的阶数是等于键值的数量的，如果B+树一个节点可以存储1000个键值(即1000阶B+树)，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以查找10亿数据，只需要2次磁盘IO。

2. B+树中每个节点（数据页）通过双向链表互相连接。每个叶子节点中键值对数据通过单向链表连接。这样使得数据按照顺序排序，会让B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。

innodb存储引擎中B+树索引实现方式：
* B+树中的每个数据页通过双向链表连接。每个叶子节点中数据之间通过单向链表连接。如上图。

MyISAM存储引擎中的B+树索引实现方式：
* 在MyISAM存储引擎中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。

B+树索引查询数据步骤：例如查询id>=18并且id<40的用户数据,如下图

![20221108170416.png](../blog_img/20221108170416.png)

1. 一般根节点都是常驻内存的，此时直接从内存中读取页1即可。从页1中可以找到键值18，根据指针p2，定位到页3。
2. 从磁盘中读取页3后将页3放入内存中，然后进行查找，可以找到键值18，然后拿到页3中的指针p1，定位到页8。
3. 再从磁盘中将页8读取到内存中。因为页8中的数据是单向链表进行连接的，而且键值是按照顺序存放的，此时根据二分查找法定位到键值18。然后依次进行遍历查找并匹配满足条件的数据。一直找到键值为22的数据，然后页8中就没有数据了，此时根据页8中的p指针去读取页9中的数据。
4. 再从磁盘中将页9读取到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。查找到此终止。最终找到满足条件的12条数据。

## 事务

### 什么是数据库事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组sql操作，要么都执行，要么都不执行。

### 事物的四大特性(ACID)

1. 原子性（atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性（consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
3. 隔离性（isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性（durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

### 什么是脏写，脏读，不可重复读，幻读？

当多事务并发执行数据库操作时会遇到以下问题。

1. 脏写
如果一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。

![mysql20220718111415.png](../blog_img/mysql20220718111415.png)

2. 脏读
如果一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。

![mysql20220718111920.png](../blog_img/mysql20220718111920.png)

3. 不可重复读
若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。

![mysql20220718114310.png](../blog_img/mysql20220718114310.png)

4. 幻读
幻读强调的是一个事务A按照某个相同条件多次读取记录时，之后读到了之前没有读到的记录。

如果事务A先根据某些条件查询出一些记录，之后另一个已提交的事务B又向表中插入记录，事务A再次按照该条件查询时，会把事务B插入的记录也读出来。即事务执行期间，多次查询结果的条数不相同。这就是幻读

![mysql20220718114853.png](../blog_img/mysql20220718114853.png)


<font color="red">

不可重复读和幻读的区别：
1. 不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。
2. 幻读的重点在于新增或者删除；同样的条件，第1次和第2次读出来的记录数不一样。

</font>

### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题

<font color="red">

1. 由于脏写是最严重的问题，所以4种隔离级别都会禁止脏写问题的出现。
2. Mysql中InnoDB存储引擎默认的支持隔离级别是可重复读

</font>

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

SQL标准定义了四个隔离级别：
* READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

## 锁

### 对MySQL的锁了解吗?

当数据库有并发事务的时候，可能会产生数据的不一致的问题，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。


### 从锁的类别上分类,MySQL都有哪些锁呢？

从锁的类别上来讲，有共享锁和排他锁。

* 共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
* 排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，排他锁和其他的排他锁，共享锁都相斥。

### 从锁的粒度上分类,MySQL都有哪些锁呢？

在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁、表级锁和页级锁。

MyISAM和InnoDB存储引擎使用的锁：
* MyISAM采用表级锁。
* InnoDB支持行级锁和表级锁，默认为行级锁。

行级锁：
* 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。
* 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页级锁：
* 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
* 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

表级锁：
* 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。表级锁定也分为表共享锁与表排他锁。
* 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

### 隔离级别与锁的关系?

在读未提交（Read Uncommitted）级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在读已提交（Read Committed）级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在可重复读（Repeatable Read）级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

串行化（SERIALIZABLE）是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

### MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁?

例: select * from tab_with_index where id = 1 for update;for update 
可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起。

### 什么是死锁？怎么解决？

死锁是指多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法
1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁


### 乐观锁、悲观锁、共享锁、排它锁、行锁、表锁、死锁概念的理解

在面试中常问的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？

#### 乐观锁

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。

乐观锁实现方式：
一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

#### 悲观锁
悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，所以悲观锁需要耗费较多的时间。

另外，共享锁和排它锁是悲观锁的两种实现，它俩都属于悲观锁的范畴。

### 共享锁（读锁）
共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。

### 排它锁（写锁）
排他锁又称写锁。

若事务T对数据A加上排他锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到事务T释放A上的锁。这保证了其他事务在事务T释放A上的排他锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁

### 死锁

死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

解除死锁的方法：杀死死锁状态下的进程。


## 视图

视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。

### 视图的使用场景有哪些？

视图根本用途：简化sql查询，提高开发效率。兼容老的表结构。

下面是视图的常见使用场景：重用SQL语句；
* 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；使用表的组成部分而不是整个表；
* 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
* 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据

### 视图的优缺点
优点：
1. 查询简单化。视图能简化用户的操作。
2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护。

缺点：
1. 性能。数据库把视图的查询转化成对基本表的查询，若视图是由一个复杂的多表查询所定义，那么需要花费一定的
时间。

## 存储过程

存储过程是一个预编译的SQL语句，如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

优点
1） 存储过程是预编译过的，执行效率高。
2） 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
3） 安全性高，执行存储过程需要有一定权限的用户。
4） 存储过程可以重复使用，减少数据库开发人员的工作量。

缺点
1） 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，若用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。

## 常用SQL语句

### SQL约束有哪几种？

SQL 约束有哪几种？
* NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
* UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
* PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
* FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。

### varchar与char的区别?

* char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；

* varchar表示可变长字符串，长度是可变的；插入的数据是多长，就按照多长来存储；
varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；

* 总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。
