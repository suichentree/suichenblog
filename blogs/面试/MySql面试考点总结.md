---
title: MySql面试考点总结
date: 2022-10-31
sidebar: 'auto'
categories: 
 - 面试
tags:
 - MySql
---

[toc]

# MySql面试考点总结

## mysql有那些数据类型

整数类型
```
tinyInt         很小的整数(8位二进制)
smallint        小的整数(16位二进制)
mediumint       中等大小的整数(24位二进制)
int(integer)    普通大小的整数(32位二进制)
```

小数类型
```
float           单精度浮点数
double          双精度浮点数
decimal(m,d)    压缩严格的定点数
```

日期类型
```
year            YYYY
time            HH:MM:SS
date            YYYY-MM-DD
datetime        YYYY-MM-DD HH:MM:SS
timestamp       YYYY-MM-DD HH:MM:SS
```

文本、二进制类型
```
CHAR(M)         M为0~65535之间的整数
VARCHAR(M)      M为0~65535之间的整数
BLOB            允许长度0~65535字节
TEXT            允许长度0~65535字节
BINARY(M)       允许长度0~M个字节的定长字节字符串
```

## 存储引擎

常用的存储引擎有以下：
* Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
* MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。


## 索引
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

索引可以快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。

通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。

### 索引种类

* 主键索引:数据列不允许重复，不允许为NULL，一个表只能有一个主键。
* 唯一索引:数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。
    - 可以通过ALTER TABLE table_name ADD UNIQUE(column);创建唯一索引
    - 可以通过ALTER TABLE table_name ADD UNIQUE(column1,column2);创建唯一组合索引
* 普通索引:基本的索引类型，没有唯一性的限制，允许为NULL值。
    - 可以通过ALTER TABLE table_name ADD INDEX index_name(column);创建普通索引
    - 可以通过ALTER TABLE table_name ADD INDEX index_name(column1,column2,column3);创建组合索引
* 全文索引：是目前搜索引擎使用的一种关键技术。
    - 可以通过ALTERTABLEtable_nameADDFULLTEXT(column);创建全文索引。


### 组合索引是什么？为什么需要注意联合索引中的顺序？

MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。

具体原因为:
MySQL使用索引时需要索引有序，假设现在建立了"name，age，school"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。

当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。

因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。

### 什么是最左前缀原则？什么是最左匹配原则?

顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。

最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a=1andb=2andc>3andd=4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。=和in可以乱序，比如a=1 and b=2 and c=3建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式

### 为什么用B+树作为索引？

索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。 

PS:索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在`[1,2,3,4]`中找到4这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。

介绍B+树索引，就不得不提二叉查找树，平衡二叉树和B树这三种数据结构。B+树就是从它们演化来的。

#### 二叉查找树

![20221107175851.png](../blog_img/20221107175851.png)


















## 事务

### 什么是数据库事务？

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组sql操作，要么都执行，要么都不执行。

### 事物的四大特性(ACID)

1. 原子性（atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. 一致性（consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的。
3. 隔离性（isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性（durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。


### 什么是脏写，脏读，不可重复读，幻读？

当事务并发执行时会遇到以下问题。

1. 脏写
如果一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。

![mysql20220718111415.png](../blog_img/mysql20220718111415.png)

2. 脏读
如果一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。

![mysql20220718111920.png](../blog_img/mysql20220718111920.png)

3. 不可重复读
若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。

![mysql20220718114310.png](../blog_img/mysql20220718114310.png)

4. 幻读
幻读强调的是一个事务A按照某个相同条件多次读取记录时，之后读到了之前没有读到的记录。

如果事务A先根据某些条件查询出一些记录，之后另一个已提交的事务B又向表中插入记录，事务A再次按照该条件查询时，会把事务B插入的记录也读出来。即事务执行期间，多次查询结果的条数不相同。这就是幻读

![mysql20220718114853.png](../blog_img/mysql20220718114853.png)


<font color="red">

不可重复读和幻读的区别：
1. 不可重复读的重点是修改；同样的条件，第1次和第2次读取的值不一样。
2. 幻读的重点在于新增或者删除；同样的条件，第1次和第2次读出来的记录数不一样。

</font>

### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？

为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题

<font color="red">

1. 由于脏写是最严重的问题，所以4种隔离级别都会禁止脏写问题的出现。
2. Mysql中InnoDB存储引擎默认的支持隔离级别是可重复读

</font>

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

SQL标准定义了四个隔离级别：
* READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
* READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
* REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
* SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

## 锁

### 对MySQL的锁了解吗?

当数据库有并发事务的时候，可能会产生数据的不一致的问题，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。


### 从锁的类别上分类,MySQL都有哪些锁呢？

从锁的类别上来讲，有共享锁和排他锁。

* 共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
* 排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，排他锁和其他的排他锁，共享锁都相斥。

### 从锁的粒度上分类,MySQL都有哪些锁呢？

在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁、表级锁和页级锁。

MyISAM和InnoDB存储引擎使用的锁：
* MyISAM采用表级锁。
* InnoDB支持行级锁和表级锁，默认为行级锁。

行级锁：
* 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。
* 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

页级锁：
* 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。
* 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

表级锁：
* 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。表级锁定也分为表共享锁与表排他锁。
* 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

### 隔离级别与锁的关系?

在读未提交（Read Uncommitted）级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突

在读已提交（Read Committed）级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；

在可重复读（Repeatable Read）级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。

串行化（SERIALIZABLE）是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。

### MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁?

例: select * from tab_with_index where id = 1 for update;for update 
可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起。

### 什么是死锁？怎么解决？

死锁是指多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法
1. 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
2. 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
3. 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁


### 乐观锁、悲观锁、共享锁、排它锁、行锁、表锁、死锁概念的理解

在面试中常问的话题。例如，数据库如果有高并发请求，如何保证数据完整性？产生死锁问题如何排查并解决？

#### 乐观锁

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或CAS算法实现。

乐观锁实现方式：
一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。

#### 悲观锁
悲观锁就是在操作数据时，认为此操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，所以悲观锁需要耗费较多的时间。

另外，共享锁和排它锁是悲观锁的两种实现，它俩都属于悲观锁的范畴。

### 共享锁（读锁）
共享锁又称读锁，是读取操作创建的锁。其他用户可以并发读取数据，但任何事务都不能对数据进行修改（获取数据上的排他锁），直到已释放所有共享锁。

如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁。获得共享锁的事务只能读数据，不能修改数据。

### 排它锁（写锁）
排他锁又称写锁。

若事务T对数据A加上排他锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到事务T释放A上的锁。这保证了其他事务在事务T释放A上的排他锁之前不能再读取和修改A。排它锁会阻塞所有的排它锁和共享锁

### 死锁

死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

解除死锁的方法：杀死死锁状态下的进程。


## 视图

视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。

### 视图的使用场景有哪些？

视图根本用途：简化sql查询，提高开发效率。兼容老的表结构。

下面是视图的常见使用场景：重用SQL语句；
* 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；使用表的组成部分而不是整个表；
* 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；
* 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据

### 视图的优缺点
优点：
1. 查询简单化。视图能简化用户的操作。
2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护。

缺点：
1. 性能。数据库把视图的查询转化成对基本表的查询，若视图是由一个复杂的多表查询所定义，那么需要花费一定的
时间。

## 存储过程

存储过程是一个预编译的SQL语句，如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

优点
1） 存储过程是预编译过的，执行效率高。
2） 存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。
3） 安全性高，执行存储过程需要有一定权限的用户。
4） 存储过程可以重复使用，减少数据库开发人员的工作量。

缺点
1） 如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，若用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。

## 常用SQL语句

### SQL约束有哪几种？

SQL 约束有哪几种？
* NOT NULL: 用于控制字段的内容一定不能为空（NULL）。
* UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。
* PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。
* FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。

### varchar与char的区别?

* char表示定长字符串，长度是固定的；如果插入数据的长度小于char的固定长度时，则用空格填充；因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；

* varchar表示可变长字符串，长度是可变的；插入的数据是多长，就按照多长来存储；
varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；

* 总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。
