---
title: SpringCloud面试题总结
date: 2020-11-24
sidebar: 'auto'
categories:
 - 面试
tags:
 - SpringCloud
 - SpringCloudAlibaba
---

[toc]

# SpringCloud面试题总结

## CAP原则

![springcloud_20231203123051.png](../blog_img/springcloud_20231203123051.png)

CAP原则又称CAP理论，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。

> 分布式系统中的三个特性如下：
- 一致性（C）：分散在分布式系统中的同一份数据，在同一时刻是否是同样的值。
- 高可用性（A）：集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。
- 分区容错性（P）：分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了数据分区的情况。特指对网络分区的容错性。

## CAP原则例子

假设一个DB服务搭建在两个机房（北京,广州）。两个DB服务同时提供写入和读取功能。

![springcloud_20231203132210.png](../blog_img/springcloud_20231203132210.png)

> 1.假设DB的更新操作是同时写北京和广州的DB都成功才返回成功

在没有出现网络故障的时候，满足CA原则，C 即任何一个写入，更新操作成功并返回客户端完
成后,分布式的所有节点在同一时间的数据完全一致， A 即读写操作都能够成功，但是当出现
网络故障时，不能同时保证CA，即P条件无法满足

> 2.假设DB的更新操作是只写本地机房成功就返回，通过binlog方式同步至其他机房

这种操作保证了在出现网络故障时,双边机房都是可以提供服务的，且读写操作都能成功，意味着它满足了AP ，但是它不满足C，因为更新操作返回成功后，双边机房的DB看到的数据会存在短暂不
一致，且在网络故障时，不一致的时间差会很大（仅能保证最终一致性）。

> 3.假设DB的更新操作是同时写北京和广州的DB都成功才返回成功且网络故障时提供降级服务

降级服务，如停止写入，只提供读取功能，这样能保证数据是一致的，且网络故障时能提供服务，
满足CP原则，但是他无法满足A可用性原则。

## CAP原则的三种取舍策略

CAP三个特性不能同时满足，只能满足其中两个。那么取舍的策略就共有三种。

- CA：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。传统的关系型数据库Oracle、MySQL就是CA。

- CP：如果不要求A（可用性），相当于每个请求都需要在服务器之间保持强一致，而P（分
区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。

- AP：如果不要求C（一致性），一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。


CAP原则的三种取舍策略，一般根据业务场景来做出选择。

- 对于大多数互联网应用来说，因为机器数量庞大，部署节点分散，网络故障是常态，可用性是必须需要保证的，所以只有舍弃一致性来保证服务的AP。通常吹嘘5个9或6个9服务基本都是放弃C选择AP。

- 对于银行需要确保强一致性的场景。通常会权衡CA和CP模型，CA模型网络故障时完全不可用，CP模型具备部分可用性，实际的选择需要通过业务场景来权衡。


## BASE理论

BASE理论是 Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的简写。

BASE理论是对CAP原则中一致性和可用性权衡的结果，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

> BASE理论三个特性

- 基本可用(BA): 是指分布式系统在出现故障的时候，允许损失部分可用性来保证核心可用。例如部分业务功能上的损失。
- 软状态(S): 是指允许分布式系统在不同节点的数据副本之间进行数据同步的过程存在延时。
- 最终一致性(E): 是分布式系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性的本质是需要数据最终能够达到一致，而不需要保证数据实时的强一致性。


## 分布式事务解决方案有哪些？

关于分布式事务的解决方案。典型方案包括：
1. 两阶段提交（2PC, Two-phase Commit）方案
2. eBay 事件队列方案
3. TCC 补偿模式
4. 缓存数据最终一致性

### 2PC方案：强一致性

2PC的核心原理是通过将事务进行分阶段提交和记日志的方式来实现分布式事务的。

记录下事务提交所处的阶段状态，在组件宕机重启后，可通过日志恢复事务提交的阶段状态，并在这个状态节点重试

### eBay 事件队列方案: 最终一致性

它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列。

如果系统发生故障，那么可以通过业务规则进行失败重试，它要求各服务的接口是幂等的。

### TCC （Try-Confirm-Cancel）补偿模式: 最终一致性

如图所示由服务 A、服务B、服务C、服务D 共同组成的一个微服务架构系统。服务A 需要依次
调用服务B、服务C 和服务D 共同完成一个操作。当服务A 调用服务D 失败时，若要保证整个系统数据的一致性，就要对服务B 和服务C 的invoke 操作进行回滚，执行反向的revert 操作。回滚成功后，整个微服务系统是数据一致的。

![springcloud_20231203140157.png](../blog_img/springcloud_20231203140157.png)

TCC方案的实现关键：
1. 服务调用链必须被记录下来。
2. 每个服务提供者都需要提供一组业务逻辑相反的操作，互为补偿，同时回滚操作要保证幂等。
3. 必须按失败原因执行不同的回滚策略。

### 缓存数据: 最终一致性

如何解决缓存和数据库数据不一致的问题。有以下两种解决方案：
1. 为缓存数据设置过期时间。当缓存中数据过期后，业务系统会从数据库中获取数据，并将新值放入缓存。这个过期时间就是系统可以达到最终一致的容忍时间。
2. 更新数据库数据后同时清除缓存数据。数据库数据更新后，同步删除缓存中数据，使得下次直接从数据库中获取，并同步到缓存。


## 分布式锁的实现方式

分布式锁是控制分布式系统之间同步访问共享资源的一种方式。

> 分布式锁的使用场景如下：

不同服务之间共享了一个或一组资源，那么当多个服务并发访问同一个共享资源的时候，需要通过一定的互斥手段来防止彼此的干扰，以保证数据一致性。


### Redis实现分布式锁

> 方式1：通过SETNX实现分布式锁。

SETNX：当指定键不存在时，向Redis中添加一个键值对。多个Redis客户端并发访问该键值对的时候。SETNX能保证只有一个客户端能够成功访问该键值对。

利用SETNX的原子特性，和Redis的键过期特性，实现了自动过期释放的分布式锁。


## 什么是微服务？

微服务架构是一种架构模式或者说是一种架构风格。

微服务提倡将单一应用程序划分为一个个的服务，每个服务运行在其独立的自己的进程中，服务之间相互协调、互相配合，最终实现系统中的功能。

微服务中服务与服务之间采用轻量级的通信机制互相沟通,每个服务都围绕着具体的业务进行构建，并且能够被独立的构建在生产环境、类生产环境等。

## 什么是 Spring Cloud？

Spring cloud 是基于 Spring Boot 的分布式微服务解决方案。

Spring cloud 可以将基于Spring Boot开发的单体微服务整合并管理起来,是一系列框架的集合。

Spring cloud 提供如注册中心、配置中心、API网关、流量监控、断路器、链路追踪等功能。

## SpringBoot和SpringCloud的区别？

SpringBoot专注于开发单个微服务。

SpringCloud是分布式微服务系统解决方案。它将SpringBoot开发的单体微服务整合起来，提供如注册中心、配置中心、API网关、流量监控、断路器、链路追踪等功能。

## 服务注册和发现是什么意思？

由于微服务是将一个单体系统按照业务的划分，拆分为一个个服务。而一个业务通过是多个服务协同完成。那么如何一个服务去调用其他服务。并且随着业务的增长，有的服务可能废弃，有的服务可能新增。我们该如何通知这个消息给其他服务。

服务注册和服务发现是一个中台机制。可以做到以下几点。
- 必须先将所有服务的信息都注册到中台中。
- 一个服务可以通过服务注册中心，去获取到其他服务的信息。
- 每当有服务增减，其他服务也能及时获取到最新的服务信息。


## 什么是服务熔断？

熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务熔断，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。

## 什么是服务降级？

服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然水平下降，但好歹可用，比直接挂掉强。




## 什么是SpringCloudConfig?

在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。

在spring cloud config 组件中，分两个角色，一是config server，二是config client。使用：（1）添加pom依赖（2）配置文件添加相关配置（3）启动类添加注解@EnableConfigServer

## 负载平衡的意义什么？

在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。



## 为什么需要注册中心？

由于微服务架构需要把一个单体应用拆分为各个微小的服务。并且服务与服务之间需要互相配合才能完成一个业务功能。

那么各个服务之间如何互相配合？答案就是注册中心。

注册中心通过记录各个服务的信息，从而让服务与服务之间互相连通。

注册中心中存储的内容是：服务的ip+port+服务配置等。

## 如何设计一个注册中心，需要哪些接口？

- 服务注册接口：把服务注册到注册中心的功能。
- 服务心跳接口：检测注册中心的服务是否有效或者网络是否连通。
- 服务下线接口：把服务从注册中心中下线。
- 服务剔除接口：注册中心将无效的服务，从注册中心表中删除的功能。
- 查询服务接口：给其他服务提供注册中心的注册表的信息。
- 注册表同步接口：当注册中心是集群的时候，提供一个互相之间同步注册表的接口。

## 介绍一下 RESTFUL？

RESTFUL是一种编码约定。对于同一个接口，根据http请求方式的不同，来实现不同的功能。

- 对于get请求，接口实现查询功能。
- 对于post请求，接口实现新增功能。
- 对于put请求，接口实现修改功能。
- 对于delet请求，接口实现删除功能。


## 为什么微服务需要熔断机制？

熔断机制就是当服务发生故障的时候，如何进行响应的一种机制。

> 什么是服务故障？

例如网络波动异常，一时间大流量导致的处理时间过慢的异常，服务不可调用的异常等。

由于微服务架构中服务与服务之间需要互相调用才能实现业务功能。一个业务功能可能需要调用7-8个服务才能实现。但是当某个业务发生故障的时候,可能会导致涉及到该服务的业务功能全部发生故障。

当服务发生故障的时候，为了不让故障服务去影响其他服务的正常使用。我们需要通过熔断机制来限制故障服务的调用。例如直接返回默认值，限制服务的QPS等。

## 熔断和降级的区别？

相同性：熔断和降级都是一种机制。为了防止系统整体响应缓慢的机制。

不同性：熔断一般是某个业务功能中的服务（下游服务）故障导致的。而降级一般是某个服务对于大流量的请求处理缓慢，为了让服务的响应时间加快，从而限制降低了服务的请求处理。

## 微服务设计一般都遵循什么原则？

1. 单一职责原则：服务与服务之间互相独立。每个服务只处理自己的业务。做到高内聚，低耦合。
2. 服务自治原则：每个服务都能做到独立开发，独立测试，独立部署，独立运行。让服务与其他服务进行解耦。
3. 轻量通信原则：服务与服务之间的通信调用是轻量级的，并且能够跨平台，跨语言的。

## Ribbon的原理是什么？

1. 通过拦截器将被注解@LoadBalanced修改的请求进行拦截。
2. 将请求中的服务名信息，会根据注册中心的注册表，解析成具体的ip地址。如果服务名对于多个ip地址，那么ribbon在选择地址的时候，会进行负载均衡。
3. 当确定好ip地址的时候，ribbon会放行请求。

## 什么是Cache aside 缓存更新机制？

Cache aside 缓存更新机制是用于保存数据库和缓存的数据一致性的机制。

Cache aside 缓存更新机制：
1. 当应用读取数据的时候，先从缓存中读取数据，若没有得到，则从数据库中读取数据，成功后，存放到缓存中。
2. 当应用对数据进行更新的时候，先在数据库中对数据进行更新。更新成功后，将缓存中的对应数据进行删除。

> Cache aside 缓存更新机制的问题

当读取操作A比更新操作B先开始，若读取操作A比更新操作B完结束的时候。由于读取操作会将旧数据存储到缓存中，而数据库中存储的是新数据。这种情况下会缓存和数据库的数据会产生不一致。

但是由于读操作正常情况下，比写操作快。因此一般情况下，这个问题发生的概率很低。 

> 如何解决上述问题？

通过延迟双删。即当写操作更新了数据库，并且删除了缓存之后，等待2-3s,再次删除缓存。这样就会保证旧数据不会出现在缓存中。

## 什么是Read/Write Through机制？

尽管Cache aside 缓存更新机制和延迟双删的方法能够保证缓存和数据库的一致性。但是仍然有出现问题的可能。

Read/Write Through机制如下
- 读取操作和缓存交互，直接读取缓存结果。
- 写入操作也和缓存交互，直接将写入结果存储到缓存中。
- 最后缓存本身与数据库进行数据同步。

简而言之，在Read/Write Through机制中当缓存启动的时候，自身将从数据库中读取数据，并存入到缓存中。然后应用的读取写入操作都与缓存交互，缓存自身再与数据库进行数据同步。

Read/Write Through机制：应用读写数据操作-》缓存-》数据库

