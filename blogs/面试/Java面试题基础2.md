---
title: JAVA面试题-基础2
date: 2022-04-21
sidebar: 'auto'
categories:
 - 面试
tags:
 - Java
---

[toc]

## JAVA面试题-基础2


### 1 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收?

对于GC(垃圾收集器)来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，当GC确定一些对象为"不可用"时，GC就有责任回收这些内存空间。
程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。

### 2 String 和StringBuilder,StringBuffer的区别？

String的内容是不可变的。因为String的底层是一个底层不可变的字符数组（final char[]）。
StringBuffer，StringBuilder的内容可变的。它们底层是可变的字符数组（char[]）。它们用append()方法来改变内容。

```java
String s="a"+"b";
StringBuilder sb=new StringBuilder();
sb.append("a").append("b");
```

**拼接字符串时，不能使用String来进行拼接。因为开销大.要用StringBuilder或StringBuffer**

StringBuilder是线程不安全，效率高的。因为其append方法没有线程同步锁
StringBuffer是线程安全，效率低的。其append方法有线程同步锁。


### 3 ”==”与equal有何区别？

== 用于判断两个基本数据类型的值，或者两个引用类型的内存地址。
equal比较的是内容本身。

### 4 是否可以继承String类?

答：String类是final类故不可以继承。final修饰的类无法被继承

### 5. 数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？

字符串转换为基本数据类型: 
基本数据类型 + 空字符串（""）就可获得其所对应的字符串

基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；

一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串

### 6 Java中如何实现序列化，有什么意义？

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口

### 7. java中实现多态的机制是什么？

答：方法的重写Overriding和重载Overloading是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。

### 8. 说说包装类，自动装箱，自动拆箱？

Java语言是面向对象的语言，其设计理念是“一切皆对象”。但8种基本数据类型却出现了例外，它们不具备对象的特性。为了解决这个问题，Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。例如当某个方法需要Object类型的参数，但实际传入的值却是数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化。

```
// 8种基本数据类型对应的8种包装类
byte	Byte
short	Short
int	    Integer
long	Long
float	Float
double	Double
boolean	Boolean
char	Character
```

1. 自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；
2. 自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；
3. 通过自动装箱、自动拆箱功能，可以大大简化基本类型变量和包装类对象之间的转换过程。


### 9.构造方法能不能重写，重载？

构造方法不能重写。因为构造方法需要和类保持同名，而重写的要求是子类方法要和父类方法保持同名。如果允许重写构造方法的话，那么子类中将会存在与类名不同的构造方法，这与构造方法的要求是矛盾的。
构造方法能重载。


### 10. 介绍一下Object类中的方法？

```
Class<?> getClass()：返回该对象的运行时类。
boolean equals(Object obj)：判断指定对象与该对象是否相等。默认是用==来进行比较的
int hashCode()：返回该对象的hashCode值。
String toString()：返回该对象的字符串表示
wait()、notify()、notifyAll()这几个方法，通过这几个方法可以控制线程的暂停和运行。
clone()方法，该方法用于帮助其他对象来实现“自我克隆”，所谓“自我克隆”就是得到一个当前对象的副本，而且二者之间完全隔离。由于该方法使用了protected修饰，因此它只能被子类重写或调用。
finalize()方法，当系统中没有引用变量引用到该对象时，垃圾回收器调用此方法来清理该对象的资源。注意，finalize()方法何时调用、是否调用都是不确定的，我们也不要主动调用finalize()方法。从JDK9开始，这个方法被标记为不推荐使用的方法。

```

### 11 String可以被继承吗？

String类由final修饰，所以不能被继承。

> 之所以要把String类设计为不可变类，主要是出于安全和性能的考虑，可归纳为如下4点。

1. 由于字符串在任何 Java 系统中都广泛使用，会用来存储敏感信息，如账号，密码等，那么保证字符串 String 类的安全性就尤为重要了，如果字符串是可变的，容易被篡改，那我们就无法保证使用字符串进行操作时，它是安全的，很有可能出现 SQL 注入，访问危险文件等操作。
2. 在多线程中，只有不变的对象和值是线程安全的，可以在多个线程中共享数据。由于 String 天然的不可变，当一个线程”修改“了字符串的值，只会产生一个新的字符串对象，不会对其他线程的访问产生副作用，访问的都是同样的字符串数据，不需要任何同步操作。
3. 字符串作为基础的数据结构，大量地应用在一些集合容器之中，尤其是一些散列集合，在散列集合中，存放元素都要根据对象的 hashCode() 方法来确定元素的位置。由于字符串 hashcode 属性不会变更，保证了唯一性，使得类似 HashMap，HashSet 等容器才能实现相应的缓存功能。由于 String 的不可变，避免重复计算 hashcode，只要使用缓存的 hashcode 即可，这样一来大大提高了在散列集合中使用 String 对象的性能。
4. 当字符串不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的 String.intern() 方法也失效，每次创建新的字符串将在堆内开辟出新的空间，占据更多的内存。
5. 因为要保证String类的不可变，那么将这个类定义为final的就很容易理解了。如果没有final修饰，那么就会存在String的子类，这些子类可以重写String类的方法，强行改变字符串的值，这便违背了String类设计的初衷。


### 12 说一说你对字符串拼接的理解

拼接字符串有很多种方式，其中最常用的有4种，下面列举了这4种方式各自适合的场景。

```
+ 运算符：如果拼接的都是字符串直接量，则适合使用 + 运算符实现拼接；

StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；

StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；

String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；

```

### 13 两个字符串相加的底层是如何实现的？

如果拼接的都是字符串直接量，则在编译时编译器会将其直接优化为一个完整的字符串，和你直接写一个完整的字符串是一样的。
如果拼接的字符串中包含变量，则在编译时编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法，将这些字符串拼接在一起,之后再转换为String对象。

### 14 接口和抽象类的区别？

接口和抽象类的共同点：
1. 都不能被实例化，用于被其他类实现和继承。
2. 都可以包含抽象方法。

接口和抽象类的不同点：
1. 接口里不能包含普通方法；抽象类则完全可以包含普通方法。
2. 接口里只能定义静态常量，不能定义普通成员变量；抽象类里则既可以定义普通成员变量，也可以定义静态常量。
3. 接口里不包含构造器；抽象类里可以包含构造器。
4. 接口里不能包含初始化块；但抽象类则完全可以包含初始化块。
5. 一个类最多只能有一个直接父类，包括抽象类；但一个类可以直接实现多个接口。

### 15 说一说Java的四种引用方式

Java对象的四种引用方式分别是强引用、软引用、弱引用、虚引用，具体含义如下：

强引用：这是Java程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。

软引用：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。

弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。

虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。

