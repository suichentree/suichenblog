---
title: Java面试考点总结
date: 2022-10-31
sidebar: 'auto'
categories: 
 - 面试
tags:
 - Java
---

[toc]

# Java面试考点总结

# 基础语法

## 1 基本数据类型

### 8种基本数据类型，3种引用数据类型

> 8种基本数据类型
> char short int long double float boolean byte

> 引用数据类型
> 类(class)，接口(interface)，数组([])

* 字节是存储容量的基本单位。字符是数字，字母，汉字以及其他语言的各种符号。
* 1字节=8个二进制单位
* 一个二进制单位可以表现0,1两种状态。

![20221031112704.png](../blog_img/20221031112704.png)

### switch的表达式只能是什么数据类型?

目前 switch(expr)中，expr表达式只能是byte、short、char、int、enum枚举类型、String。但是长整型（long）在目前所有的java版本中都是不可以的。

### +=有隐含的强制类型转换

short s1 = 1; s1 = s1 + 1; 会报错
* 由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给short 型。

short s1 = 1; s1 += 1; 不会报错
* short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换


## 2 访问修饰符

定义：可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。

* private : 在同一类内可见。注意：不能修饰类（外部类）
* default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。
* protected : 对同一包内的类和所有子类可见。注意：不能修饰类（外部类）。
* public : 对所有类可见。

![20221031152254.png](../blog_img/20221031152254.png)


## 3 运算符

### &和&&的区别

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。

&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直 接短路掉，不会进行运算。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

## 4 关键字

### final finally finalize区别

final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法写到finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。

### this关键字的用法

this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

用法：
1.普通的直接引用，this相当于是指向当前对象本身。
2.形参与成员名字重名，用this来区分
3.引用本类的构造函数

### super关键字的用法

super可以理解为是指向自己父类对象的一个指针。

super也有三种用法：
1.普通的直接引用与this类似，super相当于是指向当前对象的父类的引用，这样就可以用
super.xxx来引用父类的成员。
2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分。
3.引用父类构造函数

### static关键字的用法

1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。
2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。
3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！
4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。

### static注意事项

1、静态只能访问静态。 
2、非静态既可以访问非静态的，也可以访问静态的。

## 5 流程控制语句

### break,continue,return的区别及作用

break 跳出当前循环，不再执行循环(结束当前的循环体)

continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)

return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

# 面向对象

## 面向对象的三大特性：封装 继承 多态

### 抽象

抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。

### 封装

封装：隐藏对象的属性和实现细节，仅对外提供公共访问方式，将变化隔离，便于使用，提高复用性和安全性。

### 继承

继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承可以提高代码复用性。继承是多态的前提。

关于继承如下 3 点请记住：
1. 子类拥有父类非 private 的属性和方法。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。

### 多态

父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。

在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口 （实现接口并覆盖接口中同一方法）。

方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。

# 类与接口

## 抽象类和接口的对比

相同点：
* 接口和抽象类都不能实例化
* 都位于继承的顶端，用于被其他实现或继承
* 都包含抽象方法，其子类或实现类都必须覆写这些抽象方法。

不同点：

xxx | 抽象类 | 接口
------------ | ------------- | -------------
声明 | 抽象类使用abstract关键字声明 | 接口使用interface关键字声明
实现 | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现
构造器 | 抽象类可以有构造器 | 子接口不能有构造器
字段声明 | 抽象类的字段声明可以是任意的 | 接口的字段默认都是 static 和 final的
访问修饰符 | 抽象类中的方法可以是任意访问修饰符 | 接口方法默认修饰符是public。并且不允许定义为private 或者protected

## 抽象类能使用 final 修饰吗？

不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承， 这样彼此就会产生矛盾，所以 final不能修饰抽象类。


# 变量与方法

## 成员变量与局部变量区别

成员变量：方法外部，类内部定义的变量。
局部变量：方法中的变量。

```
作用域
成员变量：针对整个类有效。
局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

存储位置
成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。

生命周期
成员变量：随着对象的创建而存在，随着对象的消失而消失
局部变量：当方法调用完，或者语句结束后，就自动释放。

初始值
成员变量：有默认初始值。
局部变量：没有默认初始值，使用前必须赋值。
```

## 静态变量和实例变量区别

静态变量：静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。

实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。

## 静态变量与普通变量区别

static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存
中只有一个副本，它当且仅当在类初次加载时会被初始 化。

而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。

## 静态方法和实例方法的区别

静态方法和实例方法的区别主要体现在两个方面：
1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使 用"对象名.方法名"的方式。而
实例方法只有后面这种方式。也就是说，调 用静态方法可以无需创建对象。
2. 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量 和静态方法），而不允许访
问实例成员变量和实例方法；实例方法则无此限制。

# 内部类

将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。

内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。

## 静态内部类

定义在类内部的静态类，就是静态内部类。
静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量； 静态内部类的创建方式，new 外部类.静态内部类()。

## 成员内部类

定义在类内部，成员位置上的非静态类，就是成员内部类。
成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公 有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()。

## 局部内部类

定义在方法中的内部类，就是局部内部类。
定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法 中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应 方法内，new 内部类()。

## 匿名内部类

匿名内部类就是没有名字的内部类，日常开发中使用的比较多。