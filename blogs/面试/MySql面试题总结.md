---
title: MySql面试题总结
date: 2022-10-31
sidebar: 'auto'
categories: 
 - 面试
tags:
 - MySql
---

[toc]

# MySql面试题总结

## 说说innodb存储引擎和myisam存储引擎的区别？

* 读写性能：InnoDB增删改性能更优；MyISAM查询性能更优。
* 存储结构：InnoDB在磁盘存储为一个文件；MyISAM在磁盘上存储成三个文件（表定义、数据、索引）。
* 外键：InnoDB支持外键；MyISAM不支持。
* 索引：InnoDB和MyISAM都用B+树的方式存储索引。
* 全文索引：InnoDB不支持（可通过插件等方式支持）；MyISAM默认支持。 
* 事务：InnoDB支持事务；MyISAM不支持。
* 锁：InnoDB支持行级锁；MyISAM只支持表级锁。

## 数据库的事务？

数据库的事务是一种机制。事务会把一组数据库命令作为一个整体进行操作，即这一组数据库命令要么都执行，要么都不执行。

## 事务的特性ACID

1. 原子性（atomicity）： 事务是最小的执行单位，不允许分割。原子性保证了事务中的操作要么全部完成，要么全部不完成；
2. 一致性（consistency）： 执行事务前后，数据总数保持一致。例如：A和B互相转账。一致性就是要保证转账前后，A和B的账号金额总体一样。
3. 隔离性（isolation）： 并发访问数据库时，一个事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. 持久性（durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不会丢失。

## 什么是索引？ 有哪几种索引？索引的优缺点？

索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。

> mysql 有4种不同的索引

主键索引（PRIMARY）：数据列不允许重复，不允许为NULL。
唯一索引（UNIQUE）：数据列不允许重复，允许为NULL值。
普通索引（INDEX）
全文索引（FULLTEXT）

> 优缺点

- 索引加快数据库的检索速度
- 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
- 唯一索引可以确保每一行数据的唯一性
- 索引降低了插入、删除、修改等维护任务的速度
- 索引需要占物理和数据空间

索引并非是越多越好，创建索引也需要耗费资源，一是增加了数据库的存储空间，二是在插入和删除时要花费较多的时间维护索引。

## 常见的sql优化有哪些？

1、查询语句中不要使用select *
2、在需要多表查询的情况下，减少使用子查询，多使用关联查询（left join,right join,inner join）替代
3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代
4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时，union all会更好)
5、应尽量避免在 where 子句中使用!=或<>操作符，否则存储引擎会放弃使用索引而进行全表扫描。
6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=0

## 数据库表如何优化？

当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下。

### 读写分离

经典的数据库拆分方案，主库负责写，从库负责读；

### 垂直分区（分表）

根据数据库里面数据表的相关性进行拆分。例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。

简单来说垂直拆分是指数据表列的拆分。把一张列比较多的表拆分为多张表。如图所示。

![mysql_20230825143446.png](../blog_img/mysql_20230825143446.png)

- 垂直分区的优点：可以使表的字段更少。在查询表的时候会减少数据库的I/O次数。并且由于将表拆分开，简化了表的结构，从而更加容易维护表。
- 垂直分区的缺点：由于将一个表拆分为多个表，为了维持表与表的关系。则外键字段会出现冗余。让以前查询一个表，变得需要查询多个表，从而让事务变得复杂起来。

### 水平分区（分库）

保持数据表结构不变，通过某种方式将数据表的数据分散存储。即把数据分散到不同的表或者库中，达到了分布式的目的。 

简单来说水平拆分是指数据表行的拆分。把数据行很多的表，拆分为多个相同的表，每个表存储在不同的数据库中。如图所示

![mysql_20230825145914.png](../blog_img/mysql_20230825145914.png)

例如表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，把每个信息表存储在不同数据库中，这样就可以避免单一表数据量过大对数据库性能造成影响。

注意：水平拆分能够 支持非常大的数据量存储，应用端改造也少，但分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。并且分库存储表会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。


## 分库分表之后,id 主键如何处理？

当分库分表后，若每个表的id都是从1开始自增，则容易出现相同id的问题。因此我们需要一个生成全局的id的方式。

生成全局 id 有下面这几种方式
- uuid: 不适合作为主键，因为太长了。并且无序性不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
- 数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
- 利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
- 美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。

## 说一说drop、delete与truncate的区别

SQL中的drop、delete、truncate都表示删除，但是三者有一些差别。

- delete和truncate只删除表的数据不删除表的结构
- 速度,一般来说: drop> truncate >delete 
- delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. 
- truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.


## 什么是视图

视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查等操作。

试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询

## 什么是内联接、左外联接、右外联接？

- 内联接（Inner Join）：匹配2张表中相关联的记录。
- 左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。
- 右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右位置关系。


## 并发事务会出现哪些问题？

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- 脏读：如果一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。
- 脏写：如果一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。
- 不可重复读：若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。
- 幻读：幻读强调的是一个事务A按照某个相同条件多次读取记录时，之后读到了之前没有读到的记录。


## 事务隔离级别有哪些?MySQL的默认隔离级别是?

MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重复读）

> 4种隔离级别

<font color="red">

1. 由于脏写是最严重的问题，所以4种隔离级别都会禁止脏写问题的出现。
2. Mysql中InnoDB存储引擎默认的支持隔离级别是可重复读

</font>

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

* READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读，但是脏写问题解决了。
* READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读问题，但是幻读或不可重复读仍有可能发生。
* REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以解决脏读和不可重复读问题，但幻读仍有可能发生。
* SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。


## mysql有关权限的表都有哪几个

MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。

下面分别介绍一下这些表的结构和内容：
- user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
- db权限表：记录各个帐号在各个数据库上的操作权限。
- table_priv权限表：记录数据表级的操作权限。
- columns_priv权限表：记录数据列级的操作权限。
- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受
- GRANT和REVOKE语句的影响。

## mysql有哪些数据类型

整数类型包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。

实数类型，包括FLOAT、DOUBLE、DECIMAL。

字符串类型，包括VARCHAR、CHAR、TEXT、BLOB

枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。

日期和时间类型，尽量使用timestamp，空间效率高于datetime，

>使用策略：
- 对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。
- 对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。
- 使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。
- 尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。

## 创建索引的三种方式

第一种方式：在执行CREATE TABLE时创建索引。

第二种方式：使用ALTER TABLE命令去增加索引。

第三种方式：使用CREATE INDEX命令创建。

## MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁?


可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起。

## 当WHERE子句、GROUP BY子句、HAVING子句、ORDER BY子句同时出现在一个SQL查询语块中时，执行顺序为？

常见的一些语句执行顺序： 1 from 2 where 3 group by 4 having 5 select 6 order by 7 limit 

## 请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

当多个事务并发执行数据库操作时会遇到以下4种问题。4种问题的严重程度：脏写 > 脏读 > 不可重复读 > 幻读。

- 脏写：一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。
- 脏读：一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。
- 不可重复读：若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。
- 幻读：如果事务A先根据某些条件查询出一些记录，之后另一个已提交的事务B又向表中插入记录，事务A再次按照该条件查询时，会把事务B插入的记录也读出来。即事务执行期间，多次查询结果的条数不相同。这就是幻读


为了解决事务并发运行时出现的4种问题。mysql设计了4种隔离级别。

- 读未提交：解决脏写问题。其他3个问题不行。
- 读已提交：解决脏读，脏写问题。其他2个问题不行
- 可重复度：解决不可重复读，脏读，脏写问题。其他1个问题不行
- 串行化：4个问题都能解决。

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

## Mysql 中有哪几种锁？

MyISAM 支持表锁，InnoDB 支持表锁，页锁和行锁，默认为行锁

* 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并
发量最低
* 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最
高
* 页级锁：处于表级锁和行级锁之间。
