---
title: MySql面试题总结
date: 2022-10-31
sidebar: 'auto'
categories: 
 - 面试
tags:
 - MySql
---

[toc]

# MySql面试题总结

## 说说innodb存储引擎和myisam存储引擎的区别？

* 事务：InnoDB支持事务；MyISAM不支持。
* 锁：InnoDB支持行级锁；MyISAM只支持表级锁。
* 索引：InnoDB和MyISAM都用B+树的方式存储索引。
* 全文索引：InnoDB不支持（可通过插件等方式支持）；MyISAM默认支持。 
* 外键：InnoDB支持外键；MyISAM不支持。
* 读写性能：InnoDB增删改性能更优；MyISAM查询性能更优。
* 存储结构：InnoDB在磁盘存储为一个文件；MyISAM在磁盘上存储成三个文件（表定义、数据、索引）。

## MySQL中InnoDB引擎的行锁是怎么实现的？

答：InnoDB是基于索引来完成行锁?

例: select * from tab_with_index where id = 1 for update;for update 
可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id不是索引键那么InnoDB将完成表锁，并发将无从谈起。

## 当WHERE子句、GROUP BY子句、HAVING子句、ORDER BY子句同时出现在一个SQL查询语块中时，执行顺序为？

常见的一些语句执行顺序： 1 from 2 where 3 group by 4 having 5 select 6 order by 7 limit 

## 请简洁描述 Mysql 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区别？

当多个事务并发执行数据库操作时会遇到以下4种问题。4种问题的严重程度：脏写 > 脏读 > 不可重复读 > 幻读。

- 脏写：一个事务A修改了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A中的更新操作会失效。这就是脏写。
- 脏读：一个事务A读到了另一个未提交事务B修改过的数据，若事务B之后进行回滚，则事务A读取的值是一个不存在的值。这就是脏读。
- 不可重复读：若一个事务A在执行过程中多次查询某个数据。在事务A还没有结束时，另一个已经提交的事务B修改了那个数据。那么由于事务B的修改，在事务A中两次读到的数据可能不一样。即某个事务执行期间，多次查询结果值不一样。这就是不可重复读。
- 幻读：如果事务A先根据某些条件查询出一些记录，之后另一个已提交的事务B又向表中插入记录，事务A再次按照该条件查询时，会把事务B插入的记录也读出来。即事务执行期间，多次查询结果的条数不相同。这就是幻读


为了解决事务并发运行时出现的4种问题。mysql设计了4种隔离级别。

- 读未提交：解决脏写问题。其他3个问题不行。
- 读已提交：解决脏读，脏写问题。其他2个问题不行
- 可重复度：解决不可重复读，脏读，脏写问题。其他1个问题不行
- 串行化：4个问题都能解决。

![mysql20220718145105.png](../blog_img/mysql20220718145105.png)

## Mysql 中有哪几种锁？

MyISAM 支持表锁，InnoDB 支持表锁，页锁和行锁，默认为行锁

* 表级锁：开销小，加锁快，不会出现死锁。锁定粒度大，发生锁冲突的概率最高，并
发量最低
* 行级锁：开销大，加锁慢，会出现死锁。锁力度小，发生锁冲突的概率小，并发度最
高
* 页级锁：处于表级锁和行级锁之间。
