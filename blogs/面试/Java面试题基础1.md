---
title: JAVA面试题-基础1
date: 2020-11-08
sidebar: 'auto'
categories:
 - 面试
tags:
 - Java
---

[toc]

上次更新时间：2022-04-20

## JAVA面试题-基础1


### 4. short s1 = 1; s1 = s1 + 1;有错吗? short s1 = 1; s1 += 1;有错吗？

首先s1是short类型。1 是int类型。
s1 = s1 + 1; 会编译报错。需要强制转换类型 改为 s1 = (short) (s1 + 1);才行。
s1 += 1; 不会编译报错。因为 s1+= 1;相当于 s1 = (short(s1 + 1)）;其中有隐含的强制类型转换。


### 6. 解释内存中的栈(stack)、堆(heap)和方法区(method area)?

1. 通常基本数据类型的变量，对象的引用保存在栈空间；
2. 通过 new 关键字和构造器创建的对象则放在堆空间
3. 方法区存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；

### 7. Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？
Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。
Math.round()的原理是在参数上加 0.5 然后进行下取整。

### 8. is-a , has-a ,like-a ，uses-a 分别指什么意思？

is-a，是一个，代表继承关系。 如果A is-a B，那么B就是A的父类。
like-a，像一个，代表接口关系。 如果A like a B，那么B就是A的接口。
has-a，有一个，代表组合关系。 如果A has a B，那么B就是A的组成部分。
uses-a, 用一个，A uses a B 代表A类方法中的参数包含了B类。

### 9. 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？

不对，如果两个对象 x 和 y 满足 x.equals(y) == true，它们的哈希码（hash code）应当相同。

Java 对于 eqauls 方法和 hashCode 方法是这样规定的：
1. 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；


### 10. 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？

是值传递。Java 只支持参数的值传递。
当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的副本。副本的属性可以在被调用过程中被改变，但副本的改变是不会影响到原本对象的。

### 13. java数组有没有 length()方法？String 有没有 length()方法？
数组有 length 的属性。
String 有length()方法。

### 14. char 型变量中能不能存贮一个中文汉字，为什么？
可以，unicode字符集也包括汉字字符。一个 char 类型占 2 个字节（16 比特），所以放一个中文是没问题的。

### 16.抽象的（abstract）方法是否可同时是静态的（static）？

抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的

### 19.如何实现某个类的对象克隆？
两种方式：
1. 该类实现 Cloneable 接口并重写 Object 类中的 clone()方法；
2. 该类实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。

### 20.String s = new String(“xyz”);创建了几个字符串对象？
两个对象，一个是常量区的”xyz”，一个是用 new 创建在堆上的对象。

### 21.String str=“abc”和String str=new String(“abc”); 产生几个对象？
1. 前者1或0，后者2或1，先看字符串常量池，如果字符串常量池中没有，都在常量池中创建一个，如果有，前者直接引用，后者在堆内存中还需创建一个“abc”实例对象。
2. 对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。

### 23.一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。


### 26.如何实现字符串的反转及替换？

使用 String 或 StringBuffer/StringBuilder 中的方法。或者是用递归实现字符串反转，代码如下所示：

```java
public static String reverse(String originStr) {
	if(originStr == null || originStr.length() <= 1){
        return originStr;
    }else{
        return reverse(originStr.substring(1)) + originStr.charAt(0);
    }
}
```

### 27.怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？
```java
String s1 = "你好";
String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
```

### 29.equal() 和 == 区别

- 对于基本数据类型的变量， == 比较的是实际值。
- 对于引用类型的变量，==比较的是引用的地址。

<font color="red">一般情况下，equal都是比较地址。若类中重写了equal()的。equal()比较的是内容实际值。string类是重写了equal()方法，所以比较的是具体值。</font>


### 33.阐述 final、finally、finalize 的区别?

1. final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能被继承。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。
2. finally：finally是tyr..catch..finally语句中。<font color="red">无论是否抛出异常，finally代码块都会执行</font>。
2. finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。


### 34.Session和Cookie的区别？

cookie是Web服务器发送给浏览器的文本信息。浏览器将cookie存储在本地电脑上。以后浏览器给Web服务器发请求的时候，同时会发送所有为该服务器存储的cookie。

区别：
1. session存储在服务端，cookie存储在客户端。
2. session会在一定时间内存储在服务器中，当访问增多，导致服务器性能下降时。应该使用cookie
3. 单个cookie的保存的数据不超过4k。许多浏览器限制一个站点最多保存20个cookie。
4. session能够存储任意的Java对象，cookie只能存储String类型的对象


### 39.为什么 Java 中的 String 是不可变的（Immutable）？
String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。

### 41. a.hashCode() 有什么用？与 a.equals(b) 有什么关系？
hashCode() 方法是相应对象整型的 hash 值。两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。
如果类没有重写equals的方法，则equals一般是对于引用的地址。


### 43.为什么在重写 equals 方法的时候需要重写 hashCode 方法？
因为equals一般是对比引用地址，而hashCode的hash值都是通过对引用地址进行hash算法得到的。
因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。


### 1 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收?

对于GC(垃圾收集器)来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。
通常，当GC确定一些对象为"不可用"时，GC就有责任回收这些内存空间。
程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。


### 5. 数据类型之间的转换：如何将字符串转换为基本数据类型？如何将基本数据类型转换为字符串？

字符串转换为基本数据类型: 
基本数据类型 + 空字符串（""）就可获得其所对应的字符串

基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；

一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串

### 6 Java中如何实现序列化，有什么意义？

序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口

### 15 说一说Java的四种引用方式

Java对象的四种引用方式分别是强引用、软引用、弱引用、虚引用，具体含义如下：

强引用：这是Java程序中最常见的引用方式，即程序创建一个对象，并把这个对象赋给一个引用变量，程序通过该引用变量来操作实际的对象。当一个对象被一个或一个以上的引用变量所引用时，它处于可达状态，不可能被系统垃圾回收机制回收。

软引用：当一个对象只有软引用时，它有可能被垃圾回收机制回收。对于只有软引用的对象而言，当系统内存空间足够时，它不会被系统回收，程序也可使用该对象。当系统内存空间不足时，系统可能会回收它。软引用通常用于对内存敏感的程序中。

弱引用：弱引用和软引用很像，但弱引用的引用级别更低。对于只有弱引用的对象而言，当系统垃圾回收机制运行时，不管系统内存是否足够，总会回收该对象所占用的内存。当然，并不是说当一个对象只有弱引用时，它就会立即被回收，正如那些失去引用的对象一样，必须等到系统垃圾回收机制运行时才会被回收。

虚引用：虚引用完全类似于没有引用。虚引用对对象本身没有太大影响，对象甚至感觉不到虚引用的存在。如果一个对象只有一个虚引用时，那么它和没有引用的效果大致相同。虚引用主要用于跟踪对象被垃圾回收的状态，虚引用不能单独使用，虚引用必须和引用队列联合使用。
