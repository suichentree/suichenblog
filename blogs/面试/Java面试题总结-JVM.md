---
title: Java面试题总结-JVM
date: 2023-08-11
sidebar: 'auto'
categories: 
 - 面试
tags:
 - Java
---

[toc]

# Java面试题总结-JVM

## mian方法是做什么的？

main 方法是 Java 程序的入口方法，JVM 在运行某一个程序的时候会首先查找该程序的 main 方法。

## JVM 的主要组成部分及其作用

![20221103095331.png](../blog_img/20221103095331.png)


JVM包含两个子系统和两个组件：
* 两个子系统为Class loader(类装载子系统)、 Execution engine(执行引擎)；
* 两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)。

各个组成部分：
* Class loader(类装载)：根据完整类名(如:java.lang.Object)来装载class文件到运行时数据区中的方法区（method area）。
* Execution engine（执行引擎）：执行classes中的指令。
* Native Interface(本地库接口)：与 本地方法库（native libraries）交互，是其它编程语 言交互的接口。
* Runtime data area(运行时数据区域)：这就是常说的JVM的内存。

Java程序运行步骤：
1. 首先利用IDE集成开发工具编写Java源代码，源文件的后缀为.java；
2. 再利用编译器(javac命令)将源代码编译成字节码文件，字节码文件的后缀名为.class；
3. 然后JVM中的类装载器开始读取字节码文件。由于字节码文件中包含数据和指令。
4. 类加载器将字节码文件中的数据加载到运行时数据区。把字节码文件中的指令加载到执行引擎中。
5. 执行引擎将字节码文件中的指令翻译为底层系统指令。再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。

![20221103101407.png](../blog_img/20221103101407.png)


## JVM中的运行时数据区

Java 虚拟机在执行Java程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域 随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。

* 程序计数器（Program Counter Register）：当前线程所执行的字节码的行号 指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的 字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个 计数器来完成；
* 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作 数栈、动态链接、方法出口等信息；
* 本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚 拟机栈是服务 Java方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；
* Java 堆（Java Heap）：Java 虚拟机中内存大的一块，是被所有线程共享 的，几乎所有的对象实例都在这里分配内存；
* 方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变 量、即时编译后的代码等数据。

## 解释内存中的栈(stack)、堆(heap)和方法区(method area)?

1. 通常基本数据类型的变量，对象的引用保存在栈空间；
2. 通过 new 关键字和构造器创建的对象则放在堆空间
3. 方法区存储已经被 JVM 加载的类信息、常量、静态变量、JIT 编译器编译后的代码等数据；

## 堆和栈的区别?

存放内容：
* 堆存放的是对象的实例和数组。
* 栈存放的是对象的引用,局部变量，操作数栈，返回结果。

程序可见性上：
* 堆对于整个应用程序都是共享、可见的。
* 栈只对于线程是可见的。所以是线程私有。

PS:
1. 静态变量放在方法区
2. 静态的对象还是放在堆。

## 如何为对象分配堆内存

类加载完成后，接着会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式：
* 指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的的 放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小 相等的距离，这样便完成分配内
存工作。
* 空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录 那些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

## GC是什么？

GC是垃圾收集的意思。java提供gc功能可以自动监测对象是否超过作用域，从而达到垃圾回收，自动回收内容的功能。

## 简述java垃圾回收机制

在jvm中，有一个垃圾回收进程。在正常情况下不会执行，只有当jvm处于空闲时或者堆内容不足的情况下，才会执行。它会扫描jvm中没有被任何引用的对象，将它们进行垃圾回收。

## GC的垃圾对象判断方式是什么？

方式1：引用计数法。

引用计数法就是给每个对象设置一个引用计数器。若有一个地方引用这个对象时，给引用计数器+1,否则-1。当一个对象的引用计数器为0时，表示该对象没有被引用，将会被GC回收。

引用计数法有一个缺陷，即当对象A与B，互相引用的时候，此时A,B对象的引用计数器都不为0，也就无法被gc回收。因此，主流的虚拟机都没有采用引用计数法。

方式2：可达性算法（引用链法）

从一个被称为GC roots 的对象开始向下搜索。若可以搜索到对象，则该对象与GC roots 对象之间通过引用链相连。当一个对象不可搜索到GC roots对象时，表示这个对象不可以。

此时这个不可以的对象，并不会被jvm马上回收。还需要进行两次筛选判断。

可以作为GC roots 的对象。例如：虚拟机栈中的引用的对象。


## 垃圾回收的优点？

java语言添加了垃圾回收机制，它使得编写代码的过程中，不必思考内存管理的问题。垃圾回收可以有效的防止内容泄露，最大化利用内存。

垃圾回收在jvm中是作为一个低优先级的线程运行，当jvm处于空闲时或者堆内容不足的情况下，才会执行。它会扫描jvm中没有被任何引用的对象，将它们进行垃圾回收。

